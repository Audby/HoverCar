================================================================
RepopackPy Output File
================================================================

This file was generated by RepopackPy on: 2025-03-08T10:56:19.150749

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Repository structure
3. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
  distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and RepopackPy's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

For more information about RepopackPy, visit: https://github.com/abinthomasonline/repopack-py

================================================================
Repository Structure
================================================================
HoverCarControllerESP32\.skip.esp32s2
HoverCarControllerESP32\HoverCarControllerESP32.ino
HoverCarControllerESP32\controller.py
HoverCar\HoverCar.ino
HoverCar\hoverserial.h
HoverCar\util.h
Hovercar code.txt
Images\HoverCar_test_gif.gif
Images\HoverCar_test_ready.jpg
Images\Hovercar_build_setup.jpeg
Images\Pot_based_ESC.jpeg
Images\Tank_gif.gif
Images\ZeusCar.jpeg
README.md
ps5-esp32-main\Kconfig
ps5-esp32-main\README.md
ps5-esp32-main\component.mk
ps5-esp32-main\examples\ps5Connect\ps5Connect.ino
ps5-esp32-main\examples\ps5ReceiveData\ps5ReceiveData.ino
ps5-esp32-main\examples\ps5SendData\ps5SendData.ino
ps5-esp32-main\examples\ps5ViewIncomingBits\ps5ViewIncomingBits.ino
ps5-esp32-main\keywords.txt
ps5-esp32-main\library.properties
ps5-esp32-main\src\osi\allocator.h
ps5-esp32-main\src\ps5.c
ps5-esp32-main\src\ps5.h
ps5-esp32-main\src\ps5Controller.cpp
ps5-esp32-main\src\ps5Controller.h
ps5-esp32-main\src\ps5_int.h
ps5-esp32-main\src\ps5_l2cap.c
ps5-esp32-main\src\ps5_parser.c
ps5-esp32-main\src\ps5_spp.c
ps5-esp32-main\src\stack\bt_types.h
ps5-esp32-main\src\stack\btm_api.h
ps5-esp32-main\src\stack\gap_api.h
ps5-esp32-main\src\stack\hcidefs.h
ps5-esp32-main\src\stack\l2c_api.h
ps5-esp32-main\src\stack\l2cdefs.h

================================================================
Repository Files
================================================================

================
File: Hovercar code.txt
================
================================================================
RepopackPy Output File
================================================================

This file was generated by RepopackPy on: 2025-03-01T18:59:41.330427

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Repository structure
3. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
  distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and RepopackPy's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

For more information about RepopackPy, visit: https://github.com/abinthomasonline/repopack-py

================================================================
Repository Structure
================================================================
HoverCarControllerESP32\.skip.esp32s2
HoverCarControllerESP32\HoverCarControllerESP32.ino
HoverCarControllerESP32\controller.py
HoverCar\HoverCar.ino
HoverCar\hoverserial.h
HoverCar\util.h
Images\HoverCar_test_gif.gif
Images\HoverCar_test_ready.jpg
Images\Hovercar_build_setup.jpeg
Images\Pot_based_ESC.jpeg
Images\Tank_gif.gif
Images\ZeusCar.jpeg
README.md
ps5-esp32-main\Kconfig
ps5-esp32-main\README.md
ps5-esp32-main\component.mk
ps5-esp32-main\examples\ps5Connect\ps5Connect.ino
ps5-esp32-main\examples\ps5ReceiveData\ps5ReceiveData.ino
ps5-esp32-main\examples\ps5SendData\ps5SendData.ino
ps5-esp32-main\examples\ps5ViewIncomingBits\ps5ViewIncomingBits.ino
ps5-esp32-main\keywords.txt
ps5-esp32-main\library.properties
ps5-esp32-main\src\osi\allocator.h
ps5-esp32-main\src\ps5.c
ps5-esp32-main\src\ps5.h
ps5-esp32-main\src\ps5Controller.cpp
ps5-esp32-main\src\ps5Controller.h
ps5-esp32-main\src\ps5_int.h
ps5-esp32-main\src\ps5_l2cap.c
ps5-esp32-main\src\ps5_parser.c
ps5-esp32-main\src\ps5_spp.c
ps5-esp32-main\src\stack\bt_types.h
ps5-esp32-main\src\stack\btm_api.h
ps5-esp32-main\src\stack\gap_api.h
ps5-esp32-main\src\stack\hcidefs.h
ps5-esp32-main\src\stack\l2c_api.h
ps5-esp32-main\src\stack\l2cdefs.h

================================================================
Repository Files
================================================================

================
File: README.md
================
# HoverCar

This repository showcases an electric “HoverCar” project, built by repurposing two hoverboards and integrating them with custom electronics and firmware. **Disclaimer:** The code in this repo is tailored to my personal setup. While you can explore or reuse parts of it, please note that it was never designed to be a general plug-and-play solution.

## Table of Contents
1. [Project Overview](#project-overview)
2. [Background and Motivation](#background-and-motivation)
3. [Initial Experiments: The Zeus Car](#initial-experiments-the-zeus-car)
4. [Scaling Up: Tank Chassis](#scaling-up-tank-chassis)
5. [Final Stage: The HoverCar](#final-stage-the-hovercar)
6. [Electronics & Components](#electronics--components)
7. [Software & Control](#software--control)
8. [Future Plans](#future-plans)
9. [Media & Demonstrations](#media--demonstrations)
10. [License](#license)

---

## Project Overview

The **HoverCar** began as a quest to build something bigger and more functional than standard hobbyist robot kits. After experimenting with small cars and tank chassis, I moved on to repurposing hoverboard parts due to their powerful motors, controllers, and batteries—all available at a relatively low cost on the secondhand market.

> **Key takeaway:** The knowledge I gained from smaller projects (Zeus car and tank chassis) carried over to this large-scale build, though I still encountered unexpected challenges in firmware flashing, wiring, signal conversion, and more.

![HoverCar test drive](./Images/HoverCar_test_gif.gif)

## Background and Motivation

I'm a student of cybernetics and robotics who loves building practical projects to supplement theoretical knowledge. This project is a playground to learn more about motor control, firmware development, sensor integration, and wireless communication—while also having a blast driving around on a custom electric vehicle.

## Initial Experiments: The Zeus Car

I started with a mini-robot known as the **Zeus Car**, which came as a complete kit: battery, wheels, sensors, and an Arduino UNO R3.

- **Sensors** included: grayscale, camera, ultrasound, etc.
- **Customization:** I replaced the default app control with my own Python script, allowing me to drive it via a PS5 controller (using libraries like `pygame`).
- **Goal:** Learn how to manipulate sensor data and motor output in real-time. I succeeded in reading sensor data on my computer while controlling the car.
- **Limitations:** The motors (5V) couldn’t carry any significant load, but the project was a great introduction to microcontroller basics (PWM signals, RX/TX communication, battery management, and general wiring).

> **Base Zeus Car:** ![Zeus Car](./Images/ZeusCar.jpeg)

## Scaling Up: Tank Chassis

Next, I bought a **tank chassis** equipped with 12V motors. This allowed me to explore more powerful driver components.

- **Motor drivers:** Two BTS7960 drivers to interface between the Arduino’s 5V PWM signals and the 12V supply.
- **Challenges:**
  - Interpreting the datasheet for correct wiring.
  - **Crucial Lesson:** A common ground (GND) is absolutely necessary.
  - Lots of soldering and troubleshooting to ensure the motor drivers responded correctly.

> **Tank Chassis Test Drive** ![Tank chassis test drive](./Images/Tank_gif.gif)

## Final Stage: The HoverCar

The leap from a tank chassis to a hoverboard-based design wasn’t trivial, but most of the microcontroller logic was transferable:

1. **Sourcing Hoverboards:** Found two used hoverboards for under $30 each. Their motors and built-in motor controllers were ideal, but were typically locked behind proprietary firmware.
2. **Firmware Flashing:**
   - Successfully flashed custom firmware on one hoverboard controller.
   - Had issues flashing the second, so I purchased two generic brushless motor controllers (18–55V) off AliExpress.
3. **Potentiometer vs. UART:**
   - The new controllers were potentiometer-based.
   - I needed an **Arduino Mega** for multiple UART (RX/TX) pins because each hoverboard side needed its own communication channel.
   - **DAC Setup:** The controllers expected analog signals, so I needed a digital-to-analog converter to transform PWM output into a smooth analog voltage.
   - I wrestled with address conflicts, soldering missteps, and code adjustments before getting stable motor control.
4. **Wireless Control with ESP32:**
   - I wanted to drive the HoverCar wirelessly via a PS5 controller.
   - Used an **ESP32** for Bluetooth, referencing open-source libraries and examples.
   - Forwarded the controller inputs to the Arduino for the final motor commands.

### Frame and Finishing Touches

- **Frame Construction:** Used wooden planks for a base, adding some basic weatherproofing.
- **Driving Experience:** The car can move outdoors, though it’s still evolving.
- **Practical Learning:** Building this forced me to apply many cybernetics/robotics concepts—power distribution, signal processing, sensor feedback, and more.

## Electronics & Components

1. **Arduino Mega** – multiple UART pins, central microcontroller.
2. **Hoverboard Motors & Controllers** – repurposed from used hoverboards.
3. **DACs** – smoothing out PWM signals for the pot-based controllers.
4. **ESP32** – Bluetooth module for wireless control.
5. **Batteries** – integrated hoverboard battery packs (be mindful of their voltage ratings).
6. **Miscellaneous** – BTS7960 drivers (used earlier), power cables, sensors, and more.

## Software & Control

- **Language/IDE:** Mostly C/C++ in the Arduino IDE.
- **Wireless Control:** Python + `pygame` for controller inputs, Bluetooth connectivity via ESP32.
- **Firmware:** Custom code for the flashed hoverboard controllers.
- **Motor Control Logic:** PWM signals, digital-to-analog conversion, plus sensor feedback (planned for future expansions).

## Future Plans

- **Refine Code:** Clean up the repository, optimize signal handling, and reduce wiring complexity.
- **Better Drive Experience:** Improve speed control, implement smoother acceleration, and refine steering.
- **Add Sensors:** Incorporate ultrasound, LiDAR, or camera modules for autonomous features.
- **Robot Arm:** Potentially build and mount a robotic manipulator on top for actual tasks.

---

- Thanks to open-source communities whose hoverboard firmware solutions I relied on. Particularly:
- https://github.com/rodneybakiskan/ps5-esp32
- https://github.com/flo199213/Hoverboard-Firmware-Hack-Gen2
- https://github.com/RoboDurden/Hoverboard-Firmware-Hack-Gen2.x-GD32/tree/main

================
File: HoverCar\HoverCar.ino
================
/***************************************************
  TestAllWheels_DAC.ino - Two DAC version

  Hardware:
    - Arduino Mega
    - Two hoverboard controllers (front wheels), UART on Serial2 & Serial3
    - Two pot-based ESCs (rear wheels), driven by MCP4725 DAC modules at I2C addresses 0x60 and 0x61

  Usage:
    - Receives speed commands via USB Serial (Serial Monitor or from Python script).
    - Command format:
         L=NNN  -> set left side speed to NNN  (range -1000..+1000)
         R=NNN  -> set right side speed to NNN (range -1000..+1000)
         0      -> zero both sides
         S=0    -> explicit stop command
****************************************************/

#include <Wire.h>                   // For I2C
#include <Adafruit_MCP4725.h>       // For the DAC
#include "util.h"
#include "hoverserial.h"            // Provided with the hoverboard firmware library

// ========== SETTINGS ==========

// UART BAUD for the flashed hoverboard controllers
#define BAUDRATE       19200

// For clarity, define which hardware serial each side uses
#define SerialLeft     Serial2  // pins 16=TX2->RX,17=RX2->TX
#define SerialRight    Serial3  // pins 14=TX3->RX,15=TX

// Create two DAC objects
Adafruit_MCP4725 dacLeft;
Adafruit_MCP4725 dacRight;

// The addresses for your two MCP4725 boards
#define DACLEFT_ADDR   0x60
#define DACRIGHT_ADDR  0x61

// Speed variables for left and right sides
int leftSpeed  = 0;  // range: -1000..+1000
int rightSpeed = 0;  // range: -1000..+1000

// Not strictly needed, but included for completeness
SerialHover2Server oHoverFeedback;

// ===================================================
void setup() {
  // Start USB serial (to communicate with the PC/Python)
  Serial.begin(115200);
  delay(200);
  Serial.println("TestAllWheels_DAC - Starting...");

  // Clear the serial buffer
  while (Serial.available() > 0) {
    Serial.read();
  }

  // Start the hoverboard controllers (front wheels)
  SerialLeft.begin(BAUDRATE);   // Left front
  SerialRight.begin(BAUDRATE);  // Right front

  // Init I2C and DACs (rear wheels)
  Wire.begin();

  if (!dacLeft.begin(DACLEFT_ADDR)) {
    Serial.println("MCP4725 (left) not found at 0x60! Check wiring.");
    while (1);
  }
  if (!dacRight.begin(DACRIGHT_ADDR)) {
    Serial.println("MCP4725 (right) not found at 0x61! Check wiring.");
    while (1);
  }
  Serial.println("Both DACs found (rear ESCs).");

  pinMode(LED_BUILTIN, OUTPUT);
}

void loop() {
  // Blink the built-in LED every 500 ms, just to show the loop is running
  static unsigned long lastBlink = 0;
  unsigned long now = millis();
  if (now - lastBlink >= 500) {
    lastBlink = now;
    digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));
  }

  // ========== 1) Check for commands from USB Serial ==========
  if (Serial.available()) {
    String cmd = Serial.readStringUntil('\n');
    cmd.trim(); // remove trailing whitespace

    Serial.print("Received command: ");
    Serial.println(cmd);

    // "0" => zero both sides
    if (cmd.equalsIgnoreCase("0")) {
      leftSpeed  = 0;
      rightSpeed = 0;
      Serial.println("Both sides set to 0.");
    }
    // "S=0" => explicit stop
    else if (cmd.equalsIgnoreCase("S=0")) {
      leftSpeed  = 0;
      rightSpeed = 0;
      Serial.println("Motors stopped (S=0).");
    }
    // "L=NNN" => left side speed
    else if (cmd.startsWith("L=") || cmd.startsWith("l=")) {
      int val = cmd.substring(2).toInt();
      leftSpeed = val;
      Serial.print("Left speed set to ");
      Serial.println(leftSpeed);
    }
    // "R=NNN" => right side speed
    else if (cmd.startsWith("R=") || cmd.startsWith("r=")) {
      int val = cmd.substring(2).toInt();
      rightSpeed = val;
      Serial.print("Right speed set to ");
      Serial.println(rightSpeed);
    }
    else {
      Serial.println("Unrecognized command. Examples:");
      Serial.println("  0      (both sides to 0)");
      Serial.println("  S=0    (explicit stop)");
      Serial.println("  L=300  (left speed=300)");
      Serial.println("  R=-150 (right speed=-150)");
    }

    // clamp final speeds if we want to ensure Â±1000 limit
    if (leftSpeed  > 1000)  leftSpeed  = 1000;
    if (leftSpeed  < -1000) leftSpeed  = -1000;
    if (rightSpeed > 1000)  rightSpeed = 1000;
    if (rightSpeed < -1000) rightSpeed = -1000;
  }

  // ========== 2) Send speed commands to FRONT hoverboard controllers (UART) ==========
  // Negative speeds can make them go in reverse if the flashed firmware supports it
  HoverSend(SerialLeft,  0, -leftSpeed,  32);
  HoverSend(SerialRight, 0,  rightSpeed, 32);

  // ========== 3) Drive REAR ESCs with DAC (forward-only, so clamp negatives to 0) ==========
  setLeftESC(leftSpeed);
  setRightESC(rightSpeed);

  // Print current speeds for debugging
  Serial.print("Current speeds: Left=");
  Serial.print(leftSpeed);
  Serial.print(", Right=");
  Serial.println(rightSpeed);

  // short delay to avoid flooding
  delay(20); // Reduced delay
}

// ========== HELPER FUNCTIONS ==========

/**
 * Sets the voltage for the LEFT ESC using the left DAC
 * range -1000..+1000, but clamp negative to 0 for forward-only
 */
void setLeftESC(int speedValue) {
  if (speedValue < 0)  speedValue = 0;     // clamp negative to 0
  if (speedValue > 1000) speedValue = 1000;

  // Map 0..1000 to 0..4095 (12-bit DAC)
  uint16_t dacVal = map(speedValue, 0, 1000, 0, 4095);
  dacLeft.setVoltage(dacVal, false);
}

/**
 * Sets the voltage for the RIGHT ESC using the right DAC
 * range -1000..+1000, but clamp negative to 0 for forward-only
 */
void setRightESC(int speedValue) {
  if (speedValue < 0)  speedValue = 0;
  if (speedValue > 1000) speedValue = 1000;

  // Map 0..1000 to 0..4095
  uint16_t dacVal = map(speedValue, 0, 1000, 0, 4095);
  dacRight.setVoltage(dacVal, false);
}

================
File: HoverCar\hoverserial.h
================
// hoverserial.h v20231224
/*
// Variables todo
uint8_t upperLEDMaster = 0;
uint8_t lowerLEDMaster = 0;
uint8_t mosfetOutMaster = 0;
uint8_t upperLEDSlave = 0;
uint8_t lowerLEDSlave = 0;
uint8_t mosfetOutSlave = 0;
uint8_t beepsBackwards = 0;
uint8_t activateWeakening = 0;
*/

template <typename O,typename I> void HoverSetupEsp32(O& oSerial, I iBaud, I gpio_RX, I gpio_TX)
{
  // Starts the serial connection using the baud, protocol, GPIO RX, GPIO TX.
  // These are the GPIO numbers; not necessarily the pin number printed on the PCB.
  oSerial.begin(iBaud, SERIAL_8N1, gpio_RX, gpio_TX);
}
template <typename O,typename I> void HoverSetupArduino(O& oSerial, I iBaud)
{
  oSerial.begin(iBaud);
}

uint16_t CalcCRC(uint8_t *ptr, int count)
{
  uint16_t  crc;
  uint8_t i;
  crc = 0;
  while (--count >= 0)
  {
    crc = crc ^ (uint16_t) *ptr++ << 8;
    i = 8;
    do
    {
      if (crc & 0x8000)
      {
        crc = crc << 1 ^ 0x1021;
      }
      else
      {
        crc = crc << 1;
      }
    } while(--i);
  }
  return (crc);
}


#define START_FRAME         0xABCD       // [-] Start frme definition for reliable serial communication

#ifdef REMOTE_UARTBUS
  typedef struct __attribute__((packed, aligned(1))) {
     uint16_t cStart = START_FRAME;    //  = '/';
     uint8_t iSlave;    //  the slave id this message is sent from
     int16_t iSpeed;   // 100* km/h
     uint16_t iVolt;    // 100* V
     int16_t iAmp;   // 100* A
     int32_t iOdom;    // hall steps
     uint16_t checksum;
  } SerialHover2Server;
  
  //typedef struct{   // new version
  //   uint16_t cStart = START_FRAME;   // new version
  typedef struct __attribute__((packed, aligned(1))) {
     uint8_t  cStart = '/';
     uint8_t  iDataType = 0;    //  unique id for this data struct
     uint8_t  iSlave;       //  contains the slave id this message is intended for
     int16_t  iSpeed = 0;
     uint8_t  wState = 0;   // 1=ledGreen, 2=ledOrange, 4=ledRed, 8=ledUp, 16=ledDown   , 32=Battery3Led, 64=Disable, 128=ShutOff
     uint16_t checksum;
  } SerialServer2Hover;
  typedef struct __attribute__((packed, aligned(1))) {
     uint8_t  cStart = '/';
     uint8_t  iDataType = 1;    //  unique id for this data struct
     uint8_t  iSlave;       //  contains the slave id this message is intended for
     int16_t  iSpeed = 0;
     int16_t  iSteer = 0;
     uint8_t  wState = 0;   // 1=ledGreen, 2=ledOrange, 4=ledRed, 8=ledUp, 16=ledDown   , 32=Battery3Led, 64=Disable, 128=ShutOff
     uint8_t  wStateSlave = 0;   // 1=ledGreen, 2=ledOrange, 4=ledRed, 8=ledUp, 16=ledDown   , 32=Battery3Led, 64=Disable, 128=ShutOff
     uint16_t checksum;
  } SerialServer2HoverMaster;
  
  typedef struct __attribute__((packed, aligned(1))) { 
     uint8_t cStart     = '/';      //  unique id for this data struct
     uint8_t  iDataType = 2;  //  unique id for this data struct
     uint8_t  iSlave;     //  contains the slave id this message is intended for
     float  fBattFull     = 42.0;    // 10s LiIon = 42.0;
     float  fBattEmpty    = 27.0;    // 10s LiIon = 27.0;
     uint8_t  iDriveMode  = 2;      //  MM32: 0=COM_VOLT, 1=COM_SPEED, 2=SINE_VOLT, 3=SINE_SPEED
     int8_t   iSlaveNew   = -1;      //  if >= 0 contains the new slave id saved to eeprom
     uint16_t checksum;
  } SerialServer2HoverConfigMM32;

  SerialServer2HoverConfigMM32 oHoverConfig;

  template <typename O,typename D> void HoverSendData(O& oSerial, D& oData)
  {
    oData.checksum = CalcCRC((uint8_t*)&oData, sizeof(oData)-2); // first bytes except crc
    oSerial.write((uint8_t*) &oData, sizeof(oData)); 
    //DEBUGN(oData.iSlave, sizeof(oData)); 
  }

template <typename O,typename I> void HoverSend(O& oSerial, I iSteer, I iSpeed,uint8_t wStateMaster=32, uint8_t wStateSlave=0)
{
Serial.println("Sending command - Steer: " + String(iSteer) + ", Speed: " + String(iSpeed)); // Debug print
//DEBUGT("iSteer",iSteer);DEBUGN("iSpeed",iSpeed);
SerialServer2Hover oData;
oData.iSpeed = (int16_t)iSpeed;
oData.iSteer = (int16_t)iSteer;
oData.wStateMaster = wStateMaster;
oData.wStateSlave = wStateSlave;
oData.checksum = CalcCRC((uint8_t*)&oData, sizeof(SerialServer2Hover)-2); // first bytes except crc
oSerial.write((uint8_t*) &oData, sizeof(SerialServer2Hover));
//DebugOut((uint8_t*) &oData, sizeof(oData));
}
  
  void HoverLog(SerialHover2Server& oData)
  {
    DEBUGT("iSlave",oData.iSlave);
    DEBUGT("iOdom",oData.iOdom);
    DEBUGT("\tiSpeed",(float)oData.iSpeed/100.0);
    DEBUGT("\tiAmp",(float)oData.iAmp/100.0);
    DEBUGN("\tiVolt",(float)oData.iVolt/100.0);
  }
  void HoverLogConfigMM32(SerialServer2HoverConfigMM32& oConfig)
  {
    DEBUGT("config for iSlave",oConfig.iSlave);
    DEBUGT("fBattFull",oConfig.fBattFull);
    DEBUGT("fBattEmpty",oConfig.fBattEmpty);
    DEBUGT("iDriveMode",oConfig.iDriveMode);
    DEBUGN("iSlaveNew",oConfig.iSlaveNew);
  }

#else

  typedef struct __attribute__((packed, aligned(1))) {
     uint16_t cStart = START_FRAME;    //  = '/';
     int16_t iSpeedL;   // 100* km/h
     int16_t iSpeedR;   // 100* km/h
     uint16_t iVolt;    // 100* V
     int16_t iAmpL;   // 100* A
     int16_t iAmpR;   // 100* A
     int32_t iOdomL;    // hall steps
     int32_t iOdomR;    // hall steps
     uint16_t checksum;
  } SerialHover2Server;
  
  //typedef struct{   // new version
  //   uint16_t cStart = START_FRAME;   // new version
  typedef struct __attribute__((packed, aligned(1))) {  // old version
     uint8_t cStart = '/';                              // old version
     int16_t  iSpeed = 0;
     int16_t  iSteer = 0;
     uint8_t  wStateMaster = 0;   // 1=ledGreen, 2=ledOrange, 4=ledRed, 8=ledUp, 16=ledDown   , 32=Battery3Led, 64=Disable, 128=ShutOff
     uint8_t  wStateSlave = 0;   // 1=ledGreen, 2=ledOrange, 4=ledRed, 8=ledUp, 16=ledDown   , 32=Battery3Led, 64=Disable, 128=ShutOff
     uint16_t checksum;
  } SerialServer2Hover;

template <typename O,typename I> void HoverSend(O& oSerial, I iSteer, I iSpeed,uint8_t wStateMaster=32, uint8_t wStateSlave=0)
{
Serial.println("Sending command - Steer: " + String(iSteer) + ", Speed: " + String(iSpeed)); // Debug print
//DEBUGT("iSteer",iSteer);DEBUGN("iSpeed",iSpeed);
SerialServer2Hover oData;
oData.iSpeed = (int16_t)iSpeed;
oData.iSteer = (int16_t)iSteer;
oData.wStateMaster = wStateMaster;
oData.wStateSlave = wStateSlave;
oData.checksum = CalcCRC((uint8_t*)&oData, sizeof(SerialServer2Hover)-2); // first bytes except crc
oSerial.write((uint8_t*) &oData, sizeof(SerialServer2Hover));
//DebugOut((uint8_t*) &oData, sizeof(oData));
}
  
  template <typename O,typename I> void HoverSendLR(O& oSerial, I iSpeedLeft, I iSpeedRight) // -1000 .. +1000
  {
    // speed coeff in config.h must be 1.0 : (DEFAULT_)SPEED_COEFFICIENT   16384
    // steer coeff in config.h must be 0.5 : (DEFAULT_)STEER_COEFFICIENT   8192 
    HoverSend(oSerial,iSpeedRight - iSpeedLeft,(iSpeedLeft + iSpeedRight)/2);
  }
  
  void HoverLog(SerialHover2Server& oData)
  {
    DEBUGT("iOdomL",oData.iOdomL);
    DEBUGT("\tiOdomR",oData.iOdomR);
    DEBUGT("\tiSpeedL",(float)oData.iSpeedL/100.0);
    DEBUGT(" iSpeedR",(float)oData.iSpeedR/100.0);
    DEBUGT("\tiAmpL",(float)oData.iAmpL/100.0);
    DEBUGT(" iAmpR",(float)oData.iAmpR/100.0);
    DEBUGN("\tiVolt",(float)oData.iVolt/100.0);
  }

  void HoverDebug(SerialHover2Server& oData)
  {
    DEBUGTX("0",oData.iVolt);
    DEBUGTB("1",oData.iAmpL);
    DEBUGTB("2",oData.iAmpR);
    DEBUGTB("3",oData.iSpeedL);
    DEBUGN("4",oData.iSpeedR);
  }

  void HoverDebug2(SerialHover2Server& oData)
  {
    DEBUGT("0",oData.iVolt);
    DEBUGT("1",oData.iAmpL);
    DEBUGT("2",oData.iAmpR);
    DEBUGT("3",oData.iSpeedL);
    DEBUGT("4",oData.iSpeedR);
    DEBUGT("5",oData.iOdomL);
    DEBUGN("6",oData.iOdomR);
  }

#endif






void DebugOut(uint8_t aBuffer[], uint8_t iSize)
{
  for (int i=0; i<iSize; i++)
  {
    uint8_t c = aBuffer[i];
    Serial.print((c < 16) ? " 0" : " ");Serial.print(c,HEX); 
  }
  Serial.println();
}


  

#ifdef DEBUG_RX
  unsigned long iLastRx = 0;
#endif

//boolean Receive(Serial& oSerial, SerialFeedback& Feedback)
template <typename O,typename OF> boolean Receive(O& oSerial, OF& Feedback)
{
  int iTooMuch = oSerial.available() - sizeof(SerialHover2Server) + 1;
  int8_t bFirst = 1;
  while (iTooMuch >= bFirst )
  {
    byte c = oSerial.read();  // Read the incoming byte
    iTooMuch--;

    #ifdef DEBUG_RX
      //if (millis() > iLastRx + 50)  Serial.println();
      Serial.print((c < 16) ? " 0" : " ");Serial.print(c,HEX); 
      iLastRx = millis();
    #endif
    
    if (bFirst) // test first START byte
    {
      if (c == (byte)START_FRAME) //if (c == 0xCD)
      {
        bFirst = 0;
      }
    }
    else  // test second START byte
    {
      if (c == START_FRAME >>8 ) //if (c == 0xAB)
      {
        //DEBUGT(" avail",oSerial.available())
        SerialHover2Server tmpFeedback;
        byte* p = (byte *)&tmpFeedback+2; // start word already read
        for (int i = sizeof(SerialHover2Server); i>2; i--)  
          *p++    = oSerial.read();

        //while(oSerial.available()) oSerial.read();
        #ifdef DEBUG_RX
          //Serial.print(" -> ");
          //HoverLog(tmpFeedback);
        #endif

        uint16_t checksum = CalcCRC((byte *)&tmpFeedback, sizeof(SerialHover2Server)-2);
        if (checksum == tmpFeedback.checksum)
        {
            memcpy(&Feedback, &tmpFeedback, sizeof(SerialHover2Server));
            #ifdef DEBUG_RX
              Serial.println(" :-)");
            #endif
            return true;
        }
        #ifdef DEBUG_RX
          Serial.print(tmpFeedback.checksum, HEX);
          Serial.print(" != ");
          Serial.print(checksum,HEX);
          Serial.println(" :-(");
        #endif
        return false;       
      }
      if (c != (byte)START_FRAME) //if (c != 0xCD)
        bFirst = 1;
    }
  }
  return false;
}

================
File: HoverCar\util.h
================
#ifndef UTIL_H
#define UTIL_H

String ShiftValue(String &sLine, char* c)
{
  //Serial.println("ShiftValue:'"+sLine+"'");
  int i = sLine.indexOf(c);
  String s = sLine.substring(0,i);
  sLine.remove(0,i+1);
  return s;
}

boolean isUInt(String str)
{
  for(byte i=0; i<str.length(); i++)
    if (!isDigit(str.charAt(i)) )
      return false;

  return true;
}

#define ABS(a) (((a) < 0.0) ? -(a) : (a))
#define CLAMP(x, low, high) (((x) > (high)) ? (high) : (((x) < (low)) ? (low) : (x)))
#define MAP(x, xMin, xMax, yMin, yMax) ((x - xMin) * (yMax - yMin) / (xMax - xMin) + yMin)


#ifdef _DEBUG
  #define DEBUG(txt, val) {Serial.print(F(txt)); Serial.print(F(": ")); Serial.print(val);}
  #define DEBUGT(txt, val) {Serial.print(F(txt)); Serial.print(F(": ")); Serial.print(val); Serial.print(F("\t"));}
  #define DEBUGTX(txt, val) {Serial.print(F(txt)); Serial.print(F(": ")); Serial.print(val,HEX); Serial.print(F("\t"));}
  #define DEBUGTB(txt, val) {Serial.print(F(txt)); Serial.print(F(": ")); Serial.print(val,BIN); Serial.print(F("\t"));}
  #define DEBUGN(txt, val) {Serial.print(F(txt)); Serial.print(F(": ")); Serial.println(val);}
#else
  #define DEBUG(txt, val)
  #define DEBUGT(txt, val)
  #define DEBUGTX(txt, val)
  #define DEBUGTB(txt, val)
  #define DEBUGN(txt, val)
#endif

#endif // UTIL_H

================
File: HoverCarControllerESP32\controller.py
================
#!/usr/bin/env python3

import pygame
import serial
import time
import sys

def main():
    # === 1) Init Pygame ===
    pygame.init()
    pygame.joystick.init()
    joy_count = pygame.joystick.get_count()
    print(f"Pygame sees {joy_count} joysticks.", flush=True)
    joystick = None
    if joy_count > 0:
        joystick = pygame.joystick.Joystick(0)
        joystick.init()
        print(f"Using joystick: {joystick.get_name()}", flush=True)
    else:
        print("No joystick connected. Exiting.")
        sys.exit(1)

    # === 2) Init Serial ===
    try:
        ser = serial.Serial('COM3', 115200, timeout=0.1)
    except Exception as e:
        print(f"Could not open serial port: {e}")
        sys.exit(1)

    time.sleep(2)  # one-time wait to let Arduino reset
    print("Starting R2/L2 + Steering control loop...", flush=True)

    # -- Axis indices (likely for PS4/PS5 on many systems) --
    # Double-check with a quick axis print if needed
    AXIS_L2 = 4      # L2 trigger
    AXIS_R2 = 5      # R2 trigger
    AXIS_STEER = 0   # Left stick X for steering

    def convertTrigger(val):
        """
        Convert trigger from [-1..+1] => [0..1].
          - -1 means not pressed
          - +1 means fully pressed
        """
        return (val + 1.0) / 2.0

    def deadzone(value, threshold=0.05):
        return 0.0 if abs(value) < threshold else value

    loop_count = 0
    while True:
        pygame.event.pump()
        loop_count += 1

        # If joystick is present, read the triggers + steering axis
        raw_l2 = joystick.get_axis(AXIS_L2)   # typically -1..+1
        raw_r2 = joystick.get_axis(AXIS_R2)
        raw_steer = joystick.get_axis(AXIS_STEER)  # left stick X, typically -1..+1

        # Convert L2/R2 to 0..1 range
        l2_val = convertTrigger(raw_l2)  # 0=unpressed, 1=fully pressed
        r2_val = convertTrigger(raw_r2)

        # Apply a small deadzone to steering
        steer = deadzone(raw_steer, 0.05)

        # Scale triggers to 0..1000
        throttle_speed = int(r2_val * 1000)  # 0..1000
        reverse_speed  = int(l2_val * 1000)  # 0..1000
        steering_val   = int(steer * 1000)   # -1000..+1000

        # Net speed: R2 for forward, L2 for reverse => net_speed in [-1000..+1000]
        net_speed = throttle_speed - reverse_speed

        # Arcade mixing for left & right motors:
        #   left_motor  = net_speed + steering
        #   right_motor = net_speed - steering
        left_val  = net_speed + steering_val
        right_val = net_speed - steering_val

        # Clamp to -1000..+1000
        left_val  = max(-1000, min(1000, left_val))
        right_val = max(-1000, min(1000, right_val))

        # Print some debug info
        print(
            f"Loop={loop_count}, "
            f"L2={l2_val:.2f}, R2={r2_val:.2f}, Steer={steer:.2f}, "
            f"LeftVal={left_val}, RightVal={right_val}",
            flush=True
        )


        # Send commands to Arduino
        cmd_left = f"L={left_val}\n"
        cmd_right = f"R={right_val}\n"
        ser.write(cmd_left.encode('utf-8'))
        ser.write(cmd_right.encode('utf-8'))

        # Read any Arduino response
        if ser.in_waiting > 0:
            response = ser.read(ser.in_waiting).decode('utf-8', errors='ignore')
            print(f"Arduino replied: {response}", flush=True)

        # ~40 updates/second
        time.sleep(0.1)

if __name__ == "__main__":
    main()

================
File: HoverCarControllerESP32\HoverCarControllerESP32.ino
================
/*********************************************************************************
  ESP32 Sketch using Bluepad32 to read PS5 controller, then send L= / R= commands
  to Arduino Mega for your hoverboard car.

  Steps:
  1) Wire ESP32 TX/RX pins to Mega RX1/TX1 (or whichever hardware serial you use).
     - For example:
       ESP32 GPIO 17 (TX2) -> Mega pin 19 (RX1)
       ESP32 GPIO 16 (RX2) -> Mega pin 18 (TX1)
       Common GND
  2) On Mega, read from Serial1 instead of Serial (or adjust wiring to use pins 0/1).
  3) The code here does "arcade mixing":
       netSpeed = throttleSpeed - reverseSpeed
       leftVal  = netSpeed + steeringVal
       rightVal = netSpeed - steeringVal
     which matches your Python script logic.
**********************************************************************************/

#include <Arduino.h>
#include <Bluepad32.h>
#include <HardwareSerial.h>

//
// CREATE A HARDWARE SERIAL INTERFACE FOR MEGA
// We'll pick UART2 on the ESP32. On many dev boards, that uses GPIO 16 (RX2) and 17 (TX2).
// Adjust these pins if your ESP32 board uses different ones.
HardwareSerial SerialMega(2); // "2" = UART2 instance

// Bluepad32 can connect up to 4 controllers.
ControllerPtr myControllers[BP32_MAX_GAMEPADS];

// Called when a new controller connects
void onConnectedController(ControllerPtr ctl) {
  Serial.println("CALLBACK: A controller just connected!");
  for (int i = 0; i < BP32_MAX_GAMEPADS; i++) {
    if (myControllers[i] == nullptr) {
      myControllers[i] = ctl;
      Serial.printf("Assigned to slot %d\n", i);
      break;
    }
  }
}

// Called when a controller disconnects
void onDisconnectedController(ControllerPtr ctl) {
  Serial.println("CALLBACK: A controller disconnected!");
  for (int i = 0; i < BP32_MAX_GAMEPADS; i++) {
    if (myControllers[i] == ctl) {
      myControllers[i] = nullptr;
      break;
    }
  }
}

// Simple helper to clamp values
int clampValue(int v, int minV, int maxV) {
  if (v > maxV) return maxV;
  if (v < minV) return minV;
  return v;
}

void setup() {
  Serial.begin(115200);
  delay(200);
  Serial.println("ESP32 PS5 Controller with Arcade Mixing - Starting...");

  // 1) Initialize hardware serial to Arduino Mega
  //    115200 baud, 8N1, with RX/TX pins for UART2 = 16 (RX2), 17 (TX2) on many boards
  //    If your board is different, adjust the pins
  SerialMega.begin(115200, SERIAL_8N1, 16, 17);
  delay(100);

  // 2) Setup Bluepad32
  BP32.setup(&onConnectedController, &onDisconnectedController);

  // Optionally "forgetBluetoothKeys" if you want to re-pair from scratch each time
  // BP32.forgetBluetoothKeys();

  // Some gamepads might appear as multiple devices (mouse, keyboard).
  // We'll keep it simple for a standard gamepad, so we disable virtual devices:
  BP32.enableVirtualDevice(false);

  Serial.println("Setup done. Waiting for controllers...");
}

void loop() {
  // 1) Fetch controller updates
  bool updated = BP32.update();
  if (!updated) {
    // If nothing changed, just wait a bit
    delay(10);
    return;
  }

  // 2) Process each connected controller
  for (int i = 0; i < BP32_MAX_GAMEPADS; i++) {
    ControllerPtr ctl = myControllers[i];
    if (ctl && ctl->isConnected() && ctl->hasData()) {

      // A) Read throttle (R2) and brake (L2) from the Bluepad32 system
      //    Typically 0..1023 for throttle() and brake(), 0 means unpressed, 1023 means fully pressed
      int throttleRaw = ctl->throttle(); // R2
      int brakeRaw    = ctl->brake();    // L2

      // B) Read left stick X for steering, typically -512..+511
      int16_t axisX = ctl->axisX();

      // C) Convert R2 (throttle) / L2 (brake) to -1000..+1000 range using basic "map" logic
      //    netSpeed = throttle - brake, each 0..1023 => net range -1023..+1023 => -1000..+1000
      int netSpeed = map(throttleRaw - brakeRaw, -1023, 1023, -1000, 1000);

      // D) Convert axisX from -512..+511 => -1000..+1000 for steering
      int steeringVal = map(axisX, -512, 511, -1000, 1000);

      // E) Arcade mixing
      int leftVal  = netSpeed + steeringVal;
      int rightVal = netSpeed - steeringVal;

      // F) Clamp final speeds to -1000..+1000
      leftVal  = clampValue(leftVal, -1000, 1000);
      rightVal = clampValue(rightVal, -1000, 1000);

      // G) Send to Arduino Mega as "L=NNN\n" and "R=NNN\n"
      char cmdLeft[16];
      char cmdRight[16];
      sprintf(cmdLeft,  "L=%d\n", leftVal);
      sprintf(cmdRight, "R=%d\n", rightVal);

      SerialMega.print(cmdLeft);
      SerialMega.print(cmdRight);

      // (Optional) Print debugging to USB for us to see
      Serial.printf("Controller %d: throttle=%d, brake=%d, axisX=%d => L=%d, R=%d\n",
                    i, throttleRaw, brakeRaw, axisX, leftVal, rightVal);
    }
  }

  // If you want a specific loop speed, do a small delay
  delay(20);
}

================
File: ps5-esp32-main\component.mk
================
#
# Component Makefile
#

COMPONENT_SRCDIRS := src
COMPONENT_ADD_INCLUDEDIRS := src/include

COMPONENT_OBJS := src/ps5.o src/ps5_spp.o src/ps5_parser.o src/ps5_l2cap.o

COMPONENT_EXTRA_INCLUDES +=     $(IDF_PATH)/components/bt/common/include/                     \
                                $(IDF_PATH)/components/bt/host/bluedroid/common/include/      \
                                $(IDF_PATH)/components/bt/host/bluedroid/stack/include        \
                                $(IDF_PATH)/components/bt/host/bluedroid/stack/l2cap/include    \
                                $(IDF_PATH)/components/bt/host/bluedroid/osi/include

# Legacy bluedroid location include paths
# i.e. ESP-IDF prior to revision 21165edf41813482bd1d0a8183969854d1011f24
COMPONENT_EXTRA_INCLUDES +=     $(IDF_PATH)/components/bt/bluedroid/common/include/           \
                                $(IDF_PATH)/components/bt/bluedroid/stack/include             \
                                $(IDF_PATH)/components/bt/bluedroid/stack/l2cap/include         \
								$(IDF_PATH)/components/bt/bluedroid/osi/include

COMPONENT_DEPENDS := bt

================
File: ps5-esp32-main\Kconfig
================
menu ps5

    choice IDF_COMPATIBILITY
        prompt "Framework compatibility"
        default IDF_COMPATIBILITY_STABLE
        help
            The esp32-ps5 project uses internal APIs that can change without notice.

            This option allows you to use older ESP-IDF versions, in case you get compilation
            errors.

            If you are unsure which master branch revision you should take, figure out what the
            commit date is of your ESP-IDF version (by running `git show`), and look at the help
            text of each revision listed here to know their revision date.

        config IDF_COMPATIBILITY_STABLE
            bool "Latest stable release"
        config IDF_COMPATIBILITY_MASTER
            bool "Latest master revision"

        config IDF_COMPATIBILITY_MASTER_21165ED
            bool "Master branch revision 21165ed and later"
            help
                Revision date: 30-June-2019
                Revision message: Bluetooth component refactoring
        config IDF_COMPATIBILITY_MASTER_D9CE0BB
            bool "Master branch revision d9ce0bb and later"
            help
                Revision date: 13-March-2019
                Revision message: Modify esp_bt_gap_set_scan_mode() to be able to set connection modes
                                    as well as discoverable modes
        config IDF_COMPATIBILITY_MASTER_21AF1D7
            bool "Master branch revision 21af1d7 and later"
            help
                Revision date: 10-July-2018
                Revision message: Add Secure Simple Pairing
    endchoice

    config IDF_COMPATIBILITY
        int
        default 1 if IDF_COMPATIBILITY_STABLE
        default 3 if IDF_COMPATIBILITY_MASTER

        default 3 if IDF_COMPATIBILITY_MASTER_21165ED
        default 2 if IDF_COMPATIBILITY_MASTER_D9CE0BB
        default 1 if IDF_COMPATIBILITY_MASTER_21AF1D7

endmenu

================
File: ps5-esp32-main\keywords.txt
================
ps5Controller KEYWORD1
ps5 KEYWORD1

begin KEYWORD2
end KEYWORD2
isConnected KEYWORD2
setLed KEYWORD2
setRumble KEYWORD2
setFlashRate KEYWORD2
sendToController KEYWORD2
LatestPacket KEYWORD2
attach KEYWORD2
attachOnConnect KEYWORD2
attachOnDisconnect KEYWORD2
Right KEYWORD2
Down KEYWORD2
Up KEYWORD2
Left KEYWORD2
Square KEYWORD2
Cross KEYWORD2
Circle KEYWORD2
Triangle KEYWORD2
UpRight KEYWORD2
DownRight KEYWORD2
UpLeft KEYWORD2
DownLeft KEYWORD2
L1 KEYWORD2
R1 KEYWORD2
L2 KEYWORD2
R2 KEYWORD2
Share KEYWORD2
Options KEYWORD2
L3 KEYWORD2
R3 KEYWORD2
PSButton KEYWORD2
Touchpad KEYWORD2
L2Value KEYWORD2
R2Value KEYWORD2
LStickX KEYWORD2
LStickY KEYWORD2
RStickX KEYWORD2
RStickY KEYWORD2

event	KEYWORD3

================
File: ps5-esp32-main\library.properties
================
name=ps5Controller
version=2.1
author=Albert III
maintainer=Albert III
sentence=Control your ESP32 projects with a ps5 controller!
paragraph=Emulate a ps5 console tricking the ps5 controller into connecting with the ESP32.
category=Communication
url=https://github.com/aed3/ps5-esp32
architectures=esp32

================
File: ps5-esp32-main\README.md
================
# ps5-esp32
Use a ps5 controller with an ESP32.

This is heavily based on the work of Jeffery Pernis to connect a PS3 controller to an ESP32, and the PS4-esp32 library. 

PS3 controller: https://github.com/jvpernis/esp32-ps3

PS4 controller: https://github.com/aed3/PS4-esp32

[Here's a video](https://youtu.be/BmlKBs27pgE) about how the ps4 library was made.

This repo can be downloaded as a zip file and imported into the Arduino IDE as a library.

## Installation
The instructions on how to do this are base off what can be found [here](https://github.com/jvpernis/esp32-ps3/issues/3#issuecomment-517141523)
1. You can add the ESP32 boards to your Arduino IDE by adding them to the Boards Manager:
    1. Open `File -> Preferences`
    1. Paste the following URL in the `Additional Boards Manager URLs` field:
    `https://dl.espressif.com/dl/package_esp32_index.json`
    1. Open the Boards Manager with `Tools -> Board: "xxx" -> Boards Manager`
    1. Look for `esp32` (probably the last one in the list), and click `install`
    1. Select the ESP32 board you have with `Tools -> Board: "xxx"` under the section `ESP32 Arduino`
1. To install this library into your Arduino IDE:
    1. Click on the "Code" button in the top right of this page
    1. Select "Download Zip" (It's always a good idea to look through the code on this page first to make sure you know what you're downloading)
    1. In the Arduino IDE, navigate to `Sketch -> Include Library -> Add .ZIP Library`, then select the file you just downloaded


## Pairing the ps5 Controller:
When a ps5 controller is 'paired' to a ps5 console, it just means that it has stored the console's Bluetooth MAC address, which is the only device the controller will connect to. Usually, this pairing happens when you connect the controller to the ps5 console using a USB cable, and press the PS button. This initiates writing the console's (or in this case an esp32's) MAC address to the controller.

To do this, you'll need to include the controller's ip address in the ```ps5.begin()``` function during within the ```setup()``` Arduino function like below where ```1a:2b:3c:01:01:01``` is the MAC address (**note that MAC address must be unicast**):
```
void setup()
{
    ps5.begin("1a:2b:3c:01:01:01");
    Serial.println("Ready.");
}
```

**TLDR:** Connect ps5 controller with phone through bluetooth. Get the controller's bluetooth MAC address (look in About settings of phone). Replace '1a:2b:3c:01:01:01' with your controller's bluetooh MAC. Same can be done with your ps5 console if more convenient.
##
**Note: Only buttons and analog inputs have been tested. Other functions like rumble/lights/IMU might not work, but could possibly be implemented using the 'ps5ViewIncomingBits.ino' example.**

================
File: ps5-esp32-main\examples\ps5Connect\ps5Connect.ino
================
#include <ps5Controller.h>

void setup() {
  Serial.begin(115200);

  ps5.begin("1a:2b:3c:01:01:01"); //replace with MAC address of your controller
  Serial.println("Ready.");
}

void loop() {
  if (ps5.isConnected()) {
    Serial.println("Connected!");
  }

  delay(3000);
}

================
File: ps5-esp32-main\examples\ps5ReceiveData\ps5ReceiveData.ino
================
#include <ps5Controller.h>

void setup() {
  Serial.begin(921600);
  ps5.begin("1a:2b:3c:01:01:01"); //replace with MAC address of your controller
  Serial.println("Ready.");
}

void loop() {
//  while (ps5.isConnected() == false) { // commented out as ps5 controller seems to connect quicker when microcontroller is doing nothing
//    Serial.println("PS5 controller not found");
//    delay(300);
//  }

  while (ps5.isConnected() == true) {
    if (ps5.Right()) Serial.println("Right Button");
    if (ps5.Down()) Serial.println("Down Button");
    if (ps5.Up()) Serial.println("Up Button");
    if (ps5.Left()) Serial.println("Left Button");

    if (ps5.Square()) Serial.println("Square Button");
    if (ps5.Cross()) Serial.println("Cross Button");
    if (ps5.Circle()) Serial.println("Circle Button");
    if (ps5.Triangle()) Serial.println("Triangle Button");

    if (ps5.UpRight()) Serial.println("Up Right");
    if (ps5.DownRight()) Serial.println("Down Right");
    if (ps5.UpLeft()) Serial.println("Up Left");
    if (ps5.DownLeft()) Serial.println("Down Left");

    if (ps5.L1()) Serial.println("L1 Button");
    if (ps5.R1()) Serial.println("R1 Button");

    if (ps5.Share()) Serial.println("Share Button");
    if (ps5.Options()) Serial.println("Options Button");
    if (ps5.L3()) Serial.println("L3 Button");
    if (ps5.R3()) Serial.println("R3 Button");

    if (ps5.PSButton()) Serial.println("PS Button");
    if (ps5.Touchpad()) Serial.println("Touch Pad Button");

    if (ps5.L2()) {
      Serial.printf("L2 button at %d\n", ps5.L2Value());
    }
    if (ps5.R2()) {
      Serial.printf("R2 button at %d\n", ps5.R2Value());
    }

    if (ps5.LStickX()) {
      Serial.printf("Left Stick x at %d\n", ps5.LStickX());
    }
    if (ps5.LStickY()) {
      Serial.printf("Left Stick y at %d\n", ps5.LStickY());
    }
    if (ps5.RStickX()) {
      Serial.printf("Right Stick x at %d\n", ps5.RStickX());
    }
    if (ps5.RStickY()) {
      Serial.printf("Right Stick y at %d\n", ps5.RStickY());
    }

    if (ps5.Charging()) Serial.println("The controller is charging"); //doesn't work
    if (ps5.Audio()) Serial.println("The controller has headphones attached"); //doesn't work
    if (ps5.Mic()) Serial.println("The controller has a mic attached"); //doesn't work

    Serial.printf("Battery Level : %d\n", ps5.Battery()); //doesn't work

    Serial.println();
    // This delay is to make the output more human readable
    // Remove it when you're not trying to see the output
    delay(300);
  }
}

================
File: ps5-esp32-main\examples\ps5SendData\ps5SendData.ino
================
#include <ps5Controller.h>

int r = 255;
int g = 0;
int b = 0;

// Calculates the next value in a rainbow sequence
void nextRainbowColor() {
  if (r > 0 && b == 0) {
    r--;
    g++;
  }
  if (g > 0 && r == 0) {
    g--;
    b++;
  }
  if (b > 0 && g == 0) {
    r++;
    b--;
  }
}

void setup() {
  Serial.begin(115200);

  // Replace the "1a:2b:3c:01:01:01" with the MAC address
  // the controller wants to pair to
  // Note: MAC address must be unicast
  ps5.begin("1a:2b:3c:01:01:01");
  Serial.println("Ready.");
}

void loop() {
  if (ps5.isConnected()) {
    // Sets the color of the controller's front light
    // Params: Red, Green,and Blue
    // See here for details: https://www.w3schools.com/colors/colors_rgb.asp
    ps5.setLed(r, g, b);
    nextRainbowColor();

    // Sets how fast the controller's front light flashes
    // Params: How long the light is on in ms, how long the light is off in ms
    // Range: 0->2550 ms, Set to 0, 0 for the light to remain on
    ps5.setFlashRate(ps5.LStickY() * 10, ps5.RStickY() * 10);

    // Sets the rumble of the controllers
    // Params: Weak rumble intensity, Strong rumble intensity
    // Range: 0->255
    ps5.setRumble(ps5.L2Value(), ps5.R2Value());

    // Sends data set in the above three instructions to the controller
    ps5.sendToController();

    // Don't send data to the controller immediately, will cause buffer overflow
    delay(10);
  }
}

================
File: ps5-esp32-main\examples\ps5ViewIncomingBits\ps5ViewIncomingBits.ino
================
#include <ps5Controller.h>

String lastByteToBinary[64];


String byteToBinary(uint8_t byte) {
  String byteString(byte, BIN);

  for (int i = byteString.length(); i < 8; i++) {
    byteString = '0' + byteString;
  }

  return byteString;
}

/* Print bytes and bits in decreasing order where
   each byte is displayed in its group of 8 bits
   and 4 bytes are printed per line

   Example: Print 4 bytes

            Bit 8  Bit 1 Bit 8  Bit 1 Bit 8  Bit 1 Bit 8  Bit 1
            ˅      ˅     ˅      ˅     ˅      ˅     ˅      ˅
   BYTE 3 : 10101110     11010011     10101110     11010011 : BYTE 0
               ˄            ˄            ˄            ˄
            4th Byte     3rd Byte     2nd Byte     1st Byte
*/
void printBits(uint8_t* packet, int byteCount) {
  for (int byte = byteCount - 4; byte >= 0; byte -= 4) {
    lastByteToBinary[byte + 3] = byteToBinary(packet[byte + 3]);
    lastByteToBinary[byte + 2] = byteToBinary(packet[byte + 2]);
    lastByteToBinary[byte + 1] = byteToBinary(packet[byte + 1]);
    lastByteToBinary[byte] = byteToBinary(packet[byte]);

    Serial.printf("BYTE %d :\t%s %s %s %s\t: BYTE %d\n",
                  (byte + 3),
                  lastByteToBinary[byte + 3],
                  lastByteToBinary[byte + 2],
                  lastByteToBinary[byte + 1],
                  lastByteToBinary[byte],
                  byte);
  }
  Serial.println();
}

void compareBits(uint8_t* packet, int byteCount) {
  for (int byteNum = 0; byteNum < byteCount; byteNum++) {
    if (lastByteToBinary[byteNum] != byteToBinary(packet[byteNum])) {
      Serial.print("changed byte:");
      Serial.println(byteNum);
    }

  }
  Serial.println();
}

void setup() {
  Serial.begin(115200);

  ps5.begin("1a:2b:3c:01:01:01"); //replace with your MAC address
  Serial.println("Ready.");
}

void loop() {
  while (ps5.isConnected() == false) {
    Serial.println("PS5 controller not found");
  }
  delay(1000); //must have this delay for reliable first connection?
  while (ps5.isConnected() == true) {

    printBits(ps5.LatestPacket(), 64);
    delay(300);
    compareBits(ps5.LatestPacket(), 64);
  }

}

================
File: ps5-esp32-main\src\ps5.c
================
#include "ps5.h"

#include <esp_system.h>
#include <string.h>

#include "ps5_int.h"

/********************************************************************************/
/*                              C O N S T A N T S */
/********************************************************************************/

static const uint8_t hid_cmd_payload_ps5_enable[] = {0x43, 0x02};

/********************************************************************************/
/*                         L O C A L    V A R I A B L E S */
/********************************************************************************/

static ps5_connection_callback_t ps5_connection_cb = NULL;
static ps5_connection_object_callback_t ps5_connection_object_cb = NULL;
static void* ps5_connection_object = NULL;

static ps5_event_callback_t ps5_event_cb = NULL;
static ps5_event_object_callback_t ps5_event_object_cb = NULL;
static void* ps5_event_object = NULL;

static bool is_active = false;

/********************************************************************************/
/*                      P U B L I C    F U N C T I O N S */
/********************************************************************************/

/*******************************************************************************
**
** Function         ps5Init
**
** Description      This initializes the bluetooth services to listen
**                  for an incoming ps5 controller connection.
**
**
** Returns          void
**
*******************************************************************************/
void ps5Init() {
  sppInit();
  ps5_l2cap_init_services();
}

/*******************************************************************************
**
** Function         ps5IsConnected
**
** Description      This returns whether a ps5 controller is connected, based
**                  on whether a successful handshake has taken place.
**
**
** Returns          bool
**
*******************************************************************************/
bool ps5IsConnected() { return is_active; }

/*******************************************************************************
**
** Function         ps5Enable
**
** Description      This triggers the ps5 controller to start continually
**                  sending its data.
**
**
** Returns          void
**
*******************************************************************************/
void ps5Enable() {
  uint16_t length = sizeof(hid_cmd_payload_ps5_enable);
  hid_cmd_t hidCommand;

  hidCommand.code = hid_cmd_code_set_report | hid_cmd_code_type_feature;
  hidCommand.identifier = hid_cmd_identifier_ps5_enable;

  memcpy(hidCommand.data, hid_cmd_payload_ps5_enable, length);

  ps5_l2cap_send_hid(&hidCommand, length);
  ps5SetLed(32, 32, 200);
}

/*******************************************************************************
**
** Function         ps5Cmd
**
** Description      Send a command to the ps5 controller.
**
**
** Returns          void
**
*******************************************************************************/
void ps5Cmd(ps5_cmd_t cmd) {
  hid_cmd_t hidCommand = {.data = {0x80, 0x00, 0xFF}};
  uint16_t length = sizeof(hidCommand.data);

  hidCommand.code = hid_cmd_code_set_report | hid_cmd_code_type_output;
  hidCommand.identifier = hid_cmd_identifier_ps5_control;

  hidCommand.data[ps5_control_packet_index_small_rumble] = cmd.smallRumble;  // Small Rumble
  hidCommand.data[ps5_control_packet_index_large_rumble] = cmd.largeRumble;  // Big rumble

  hidCommand.data[ps5_control_packet_index_red] = cmd.r;    // Red
  hidCommand.data[ps5_control_packet_index_green] = cmd.g;  // Green
  hidCommand.data[ps5_control_packet_index_blue] = cmd.b;   // Blue

  // Time to flash bright (255 = 2.5 seconds)
  hidCommand.data[ps5_control_packet_index_flash_on_time] = cmd.flashOn;
  // Time to flash dark (255 = 2.5 seconds)
  hidCommand.data[ps5_control_packet_index_flash_off_time] = cmd.flashOff;

  ps5_l2cap_send_hid(&hidCommand, length);
}

/*******************************************************************************
**
** Function         ps5SetLedOnly
**
** Description      Sets the LEDs on the ps5 controller.
**
**
** Returns          void
**
*******************************************************************************/
void ps5SetLed(uint8_t r, uint8_t g, uint8_t b) {
  ps5_cmd_t cmd = {0};

  cmd.r = r;
  cmd.g = g;
  cmd.b = b;

  ps5Cmd(cmd);
}

/*******************************************************************************
**
** Function         ps5SetOutput
**
** Description      Sets feedback on the ps5 controller.
**
**
** Returns          void
**
*******************************************************************************/
void ps5SetOutput(ps5_cmd_t prevCommand) { ps5Cmd(prevCommand); }

/*******************************************************************************
**
** Function         ps5SetConnectionCallback
**
** Description      Registers a callback for receiving ps5 controller
**                  connection notifications
**
**
** Returns          void
**
*******************************************************************************/
void ps5SetConnectionCallback(ps5_connection_callback_t cb) {
  ps5_connection_cb = cb;
}

/*******************************************************************************
**
** Function         ps5SetConnectionObjectCallback
**
** Description      Registers a callback for receiving ps5 controller
**                  connection notifications
**
**
** Returns          void
**
*******************************************************************************/
void ps5SetConnectionObjectCallback(void* object, ps5_connection_object_callback_t cb) {
  ps5_connection_object_cb = cb;
  ps5_connection_object = object;
}

/*******************************************************************************
**
** Function         ps5SetEventCallback
**
** Description      Registers a callback for receiving ps5 controller events
**
**
** Returns          void
**
*******************************************************************************/
void ps5SetEventCallback(ps5_event_callback_t cb) { ps5_event_cb = cb; }

/*******************************************************************************
**
** Function         ps5SetEventObjectCallback
**
** Description      Registers a callback for receiving ps5 controller events
**
**
** Returns          void
**
*******************************************************************************/
void ps5SetEventObjectCallback(void* object, ps5_event_object_callback_t cb) {
  ps5_event_object_cb = cb;
  ps5_event_object = object;
}

/*******************************************************************************
**
** Function         ps5SetBluetoothMacAddress
**
** Description      Writes a Registers a callback for receiving ps5 controller
*events
**
**
** Returns          void
**
*******************************************************************************/
void ps5SetBluetoothMacAddress(const uint8_t* mac) {
  // The bluetooth MAC address is derived from the base MAC address
  // https://docs.espressif.com/projects/esp-idf/en/stable/api-reference/system/system.html#mac-address
  uint8_t baseMac[6];
  memcpy(baseMac, mac, 6);
  baseMac[5] -= 2;
  esp_base_mac_addr_set(baseMac);
}

/********************************************************************************/
/*                      L O C A L    F U N C T I O N S */
/********************************************************************************/

void ps5ConnectEvent(uint8_t is_connected) {
    if (is_connected) {
        ps5Enable();
    } else {
        is_active = false;
    }
}


void ps5PacketEvent(ps5_t ps5, ps5_event_t event) {
    // Trigger packet event, but if this is the very first packet
    // after connecting, trigger a connection event instead
    if (is_active) {
        if(ps5_event_cb != NULL) {
            ps5_event_cb(ps5, event);
        }

        if (ps5_event_object_cb != NULL && ps5_event_object != NULL) {
            ps5_event_object_cb(ps5_event_object, ps5, event);
        }
    } else {
        is_active = true;

        if(ps5_connection_cb != NULL) {
            ps5_connection_cb(is_active);
        }

        if (ps5_connection_object_cb != NULL && ps5_connection_object != NULL) {
            ps5_connection_object_cb(ps5_connection_object, is_active);
        }
    }
}

================
File: ps5-esp32-main\src\ps5.h
================
#ifndef ps5_H
#define ps5_H

#include <stdbool.h>
#include <stdint.h>

/********************************************************************************/
/*                                  T Y P E S */
/********************************************************************************/

/********************/
/*    A N A L O G   */
/********************/

typedef struct {
  int8_t lx;
  int8_t ly;
  int8_t rx;
  int8_t ry;
} ps5_analog_stick_t;

typedef struct {
  uint8_t l2;
  uint8_t r2;
} ps5_analog_button_t;

typedef struct {
  ps5_analog_stick_t stick;
  ps5_analog_button_t button;
} ps5_analog_t;

/*********************/
/*   B U T T O N S   */
/*********************/

typedef struct {
  uint8_t right : 1;
  uint8_t down : 1;
  uint8_t up : 1;
  uint8_t left : 1;

  uint8_t square : 1;
  uint8_t cross : 1;
  uint8_t circle : 1;
  uint8_t triangle : 1;

  uint8_t upright : 1;
  uint8_t downright : 1;
  uint8_t upleft : 1;
  uint8_t downleft : 1;

  uint8_t l1 : 1;
  uint8_t r1 : 1;
  uint8_t l2 : 1;
  uint8_t r2 : 1;

  uint8_t share : 1;
  uint8_t options : 1;
  uint8_t l3 : 1;
  uint8_t r3 : 1;

  uint8_t ps : 1;
  uint8_t touchpad : 1;
} ps5_button_t;

/*******************************/
/*   S T A T U S   F L A G S   */
/*******************************/

typedef struct {
  uint8_t battery;
  uint8_t charging : 1;
  uint8_t audio : 1;
  uint8_t mic : 1;
} ps5_status_t;

/********************/
/*   S E N S O R S  */
/********************/

typedef struct {
  int16_t z;
} ps5_sensor_gyroscope_t;

typedef struct {
  int16_t x;
  int16_t y;
  int16_t z;
} ps5_sensor_accelerometer_t;

typedef struct {
  ps5_sensor_accelerometer_t accelerometer;
  ps5_sensor_gyroscope_t gyroscope;
} ps5_sensor_t;

/*******************/
/*    O T H E R    */
/*******************/

typedef struct {
  uint8_t smallRumble;
  uint8_t largeRumble;
  uint8_t r, g, b;
  uint8_t flashOn;
  uint8_t flashOff;  // Time to flash bright/dark (255 = 2.5 seconds)
} ps5_cmd_t;

typedef struct {
  ps5_button_t button_down;
  ps5_button_t button_up;
  ps5_analog_t analog_move;
} ps5_event_t;

typedef struct {
  ps5_analog_t analog;
  ps5_button_t button;
  ps5_status_t status;
  ps5_sensor_t sensor;
  uint8_t* latestPacket;
} ps5_t;

/***************************/
/*    C A L L B A C K S    */
/***************************/

typedef void (*ps5_connection_callback_t)(uint8_t isConnected);
typedef void (*ps5_connection_object_callback_t)(void* object, uint8_t isConnected);

typedef void (*ps5_event_callback_t)(ps5_t ps5, ps5_event_t event);
typedef void (*ps5_event_object_callback_t)(void* object, ps5_t ps5, ps5_event_t event);

/********************************************************************************/
/*                             F U N C T I O N S */
/********************************************************************************/

bool ps5IsConnected();
void ps5Init();
void ps5Enable();
void ps5Cmd(ps5_cmd_t ps5_cmd);
void ps5SetConnectionCallback(ps5_connection_callback_t cb);
void ps5SetConnectionObjectCallback(void* object, ps5_connection_object_callback_t cb);
void ps5SetEventCallback(ps5_event_callback_t cb);
void ps5SetEventObjectCallback(void* object, ps5_event_object_callback_t cb);
void ps5SetLed(uint8_t r, uint8_t g, uint8_t b);
void ps5SetOutput(ps5_cmd_t prev_cmd);
void ps5SetBluetoothMacAddress(const uint8_t* mac);
long ps5_l2cap_connect(uint8_t addr[6]);
long ps5_l2cap_reconnect(void);

#endif

================
File: ps5-esp32-main\src\ps5Controller.cpp
================
#include "ps5Controller.h"

#include <esp_bt_defs.h>
#include <esp_bt_main.h>

extern "C" {
#include "ps5.h"
}

#define ESP_BD_ADDR_HEX_PTR(addr) \
  (uint8_t*)addr + 0, (uint8_t*)addr + 1, (uint8_t*)addr + 2, \
  (uint8_t*)addr + 3, (uint8_t*)addr + 4, (uint8_t*)addr + 5

ps5Controller::ps5Controller() {}

bool ps5Controller::begin() {
  ps5SetEventObjectCallback(this, &ps5Controller::_event_callback);
  ps5SetConnectionObjectCallback(this, &ps5Controller::_connection_callback);

  if (!btStarted() && !btStart()) {
    log_e("btStart failed");
    return false;
  }

  esp_bluedroid_status_t btState = esp_bluedroid_get_status();
  if (btState == ESP_BLUEDROID_STATUS_UNINITIALIZED) {
    if (esp_bluedroid_init()) {
      log_e("esp_bluedroid_init failed");
      return false;
    }
  }

  if (btState != ESP_BLUEDROID_STATUS_ENABLED) {
    if (esp_bluedroid_enable()) {
      log_e("esp_bluedroid_enable failed");
      return false;
    }
  }

  ps5Init();
  return true;
}

bool ps5Controller::begin(const char* mac) {
  esp_bd_addr_t addr;
    
  if (sscanf(mac, ESP_BD_ADDR_STR, ESP_BD_ADDR_HEX_PTR(addr)) != ESP_BD_ADDR_LEN) {
    log_e("Could not convert %s\n to a MAC address", mac);
    return false;
  }

  ps5_l2cap_connect(addr);
  // ps5SetBluetoothMacAddress(addr);

  return begin();
}

void ps5Controller::end() {}

bool ps5Controller::isConnected() {
  auto connected = ps5IsConnected();
  static unsigned long tryReconnectAt = 0;
  if (!connected && millis() - tryReconnectAt > 5000UL) {
    tryReconnectAt = millis();
    ps5_l2cap_reconnect();
  }
  return connected;
}

void ps5Controller::setLed(uint8_t r, uint8_t g, uint8_t b) {
  output.r = r;
  output.g = g;
  output.b = b;
}

void ps5Controller::setRumble(uint8_t small, uint8_t large) {
  output.smallRumble = small;
  output.largeRumble = large;
}

void ps5Controller::setFlashRate(uint8_t onTime, uint8_t offTime) {
  output.flashOn = onTime / 10;
  output.flashOff = offTime / 10;
}

void ps5Controller::sendToController() { ps5SetOutput(output); }

void ps5Controller::attach(callback_t callback) { _callback_event = callback; }

void ps5Controller::attachOnConnect(callback_t callback) {
  _callback_connect = callback;
}

void ps5Controller::attachOnDisconnect(callback_t callback) {
  _callback_disconnect = callback;
}

void ps5Controller::_event_callback(
  void* object, ps5_t data, ps5_event_t event) {
  ps5Controller* This = (ps5Controller*)object;

  memcpy(&This->data, &data, sizeof(ps5_t));
  memcpy(&This->event, &event, sizeof(ps5_event_t));

  if (This->_callback_event) {
    This->_callback_event();
  }
}

void ps5Controller::_connection_callback(void* object, uint8_t isConnected) {
  ps5Controller* This = (ps5Controller*)object;

  if (isConnected) {
    delay(250);  // ToDo: figure out how to know when the channel is free again
                 // so this delay can be removed

    if (This->_callback_connect) {
      This->_callback_connect();
    }
  }
  else {
    if (This->_callback_disconnect) {
      This->_callback_disconnect();
    }
  }
}

#if !defined(NO_GLOBAL_INSTANCES)
ps5Controller ps5;
#endif

================
File: ps5-esp32-main\src\ps5Controller.h
================
#ifndef ps5Controller_h
#define ps5Controller_h

#include "Arduino.h"

extern "C" {
#include "ps5.h"
}

class ps5Controller {
 public:
  typedef void (*callback_t)();

  ps5_t data;
  ps5_event_t event;
  ps5_cmd_t output;

  ps5Controller();

  bool begin();
  bool begin(const char* mac);
  void end();

  bool isConnected();

  void setLed(uint8_t r, uint8_t g, uint8_t b);
  void setRumble(uint8_t small, uint8_t large);
  void setFlashRate(uint8_t onTime, uint8_t offTime);

  void sendToController();

  void attach(callback_t callback);
  void attachOnConnect(callback_t callback);
  void attachOnDisconnect(callback_t callback);

  uint8_t* LatestPacket() { return data.latestPacket; }

public:
  bool Right() { return data.button.right; }
  bool Down() { return data.button.down; }
  bool Up() { return data.button.up; }
  bool Left() { return data.button.left; }

  bool Square() { return data.button.square; }
  bool Cross() { return data.button.cross; }
  bool Circle() { return data.button.circle; }
  bool Triangle() { return data.button.triangle; }

  bool UpRight() { return data.button.upright; }
  bool DownRight() { return data.button.downright; }
  bool UpLeft() { return data.button.upleft; }
  bool DownLeft() { return data.button.downleft; }

  bool L1() { return data.button.l1; }
  bool R1() { return data.button.r1; }
  bool L2() { return data.button.l2; }
  bool R2() { return data.button.r2; }

  bool Share() { return data.button.share; }
  bool Options() { return data.button.options; }
  bool L3() { return data.button.l3; }
  bool R3() { return data.button.r3; }

  bool PSButton() { return data.button.ps; }
  bool Touchpad() { return data.button.touchpad; }

  uint8_t L2Value() { return data.analog.button.l2; }
  uint8_t R2Value() { return data.analog.button.r2; }

  int8_t LStickX() { return data.analog.stick.lx; }
  int8_t LStickY() { return data.analog.stick.ly; }
  int8_t RStickX() { return data.analog.stick.rx; }
  int8_t RStickY() { return data.analog.stick.ry; }

  uint8_t Battery() { return data.status.battery; }
  bool Charging() { return data.status.charging; }
  bool Audio() { return data.status.audio; }
  bool Mic() { return data.status.mic; }

 private:
  static void _event_callback(void* object, ps5_t data, ps5_event_t event);
  static void _connection_callback(void* object, uint8_t isConnected);

  callback_t _callback_event = nullptr;
  callback_t _callback_connect = nullptr;
  callback_t _callback_disconnect = nullptr;
};

#ifndef NO_GLOBAL_INSTANCES
extern ps5Controller ps5;
#endif

#endif

================
File: ps5-esp32-main\src\ps5_int.h
================
#ifndef ps5_INT_H
#define ps5_INT_H

#include "sdkconfig.h"

/** Check if the project is configured properly */
#ifndef ARDUINO_ARCH_ESP32

/** Check the configured blueooth mode */
#ifdef CONFIG_BTDM_CONTROLLER_MODE_BTDM
#define BT_MODE ESP_BT_MODE_BTDM
#elif defined CONFIG_BTDM_CONTROLLER_MODE_BR_EDR_ONLY
#define BT_MODE ESP_BT_MODE_CLASSIC_BT
#else
#error \
  "The selected Bluetooth controller mode is not supported by the ESP32-ps5 module"
#endif

#endif  // ARDUINO_ARCH_ESP32

/* Detect ESP-IDF releases */
#if __has_include("esp_idf_version.h")
#include <esp_idf_version.h>

#else

/* Detect Arduino releases */
#if __has_include("core_version.h")
#include <core_version.h>
#endif


/* Arduino releases using IDF v3.2.3 */
#if defined(ARDUINO_ESP32_RELEASE_1_0_4) || defined(ARDUINO_ESP32_RELEASE_1_0_3)
#define ESP_IDF_VERSION_MAJOR 3
#define ESP_IDF_VERSION_MINOR 2
#define ESP_IDF_VERSION_PATCH 3
#endif

/* Arduino releases using IDF v3.2.2 */
#if defined(ARDUINO_ESP32_RELEASE_1_0_3) || defined(ARDUINO_ESP32_RELEASE_1_0_2) || defined(ARDUINO_ESP32_RELEASE_1_0_1) || defined(ARDUINO_ESP32_RELEASE_1_0_0)
#define ESP_IDF_VERSION_MAJOR 3
#define ESP_IDF_VERSION_MINOR 2
#define ESP_IDF_VERSION_PATCH 2
#endif

// Macro to convert IDF version number into an integer
#define ESP_IDF_VERSION_VAL(major, minor, patch) ((major << 16) | (minor << 8) | (patch))

// Current IDF version, as an integer
#define ESP_IDF_VERSION  ESP_IDF_VERSION_VAL(ESP_IDF_VERSION_MAJOR, \
                                             ESP_IDF_VERSION_MINOR, \
                                             ESP_IDF_VERSION_PATCH)

#endif // __has_include("esp_idf_version.h")

/** ESP-IDF compatibility configuration option choices */
#define IDF_COMPATIBILITY_MASTER_21165ED 3
#define IDF_COMPATIBILITY_MASTER_D9CE0BB 2
#define IDF_COMPATIBILITY_MASTER_21AF1D7 1

#ifndef CONFIG_IDF_COMPATIBILITY
#define CONFIG_IDF_COMPATIBILITY IDF_COMPATIBILITY_MASTER_21165ED
#endif

/** Size of the output report buffer for the Dualshock and Navigation
 * controllers */
#define ps5_SEND_BUFFER_SIZE 77
#define ps5_HID_BUFFER_SIZE 50

/********************************************************************************/
/*                         S H A R E D   T Y P E S */
/********************************************************************************/

enum hid_cmd_code {
  hid_cmd_code_set_report = 0x50,
  hid_cmd_code_type_output = 0x02,
  hid_cmd_code_type_feature = 0x03
};

enum hid_cmd_identifier {
  hid_cmd_identifier_ps5_enable = 0xF4,
  hid_cmd_identifier_ps5_control = 0x11
};

typedef struct {
  uint8_t code;
  uint8_t identifier;
  uint8_t data[ps5_SEND_BUFFER_SIZE];
} hid_cmd_t;

enum ps5_control_packet_index {
  ps5_control_packet_index_small_rumble = 5,
  ps5_control_packet_index_large_rumble = 6,

  ps5_control_packet_index_red = 7,
  ps5_control_packet_index_green = 8,
  ps5_control_packet_index_blue = 9,

  ps5_control_packet_index_flash_on_time = 10,
  ps5_control_packet_index_flash_off_time = 11
};

/********************************************************************************/
/*                     C A L L B A C K   F U N C T I O N S */
/********************************************************************************/

void ps5ConnectEvent(uint8_t isConnected);
void ps5PacketEvent(ps5_t ps5, ps5_event_t event);

/********************************************************************************/
/*                      P A R S E R   F U N C T I O N S */
/********************************************************************************/

void parsePacket(uint8_t* packet);

/********************************************************************************/
/*                          S P P   F U N C T I O N S */
/********************************************************************************/

void sppInit();

/********************************************************************************/
/*                          G A P   F U N C T I O N S */
/********************************************************************************/

void ps5_l2cap_init_services();
void ps5_l2cap_deinit_services();
void ps5_l2cap_send_hid(hid_cmd_t *hid_cmd, uint8_t len);

#endif

================
File: ps5-esp32-main\src\ps5_l2cap.c
================
#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include "ps5.h"
#include "ps5_int.h"
#include "esp_log.h"
#include "esp_bt.h"
#include "esp_bt_main.h"
#include "esp_gap_bt_api.h"
#include "stack/gap_api.h"
#include "stack/bt_types.h"
#include "stack/l2c_api.h"
#include "osi/allocator.h"

#define  ps5_TAG "ps5_L2CAP"



/********************************************************************************/
/*              L O C A L    F U N C T I O N     P R O T O T Y P E S            */
/********************************************************************************/

static void ps5_l2cap_init_service(const char *name, uint16_t psm, uint8_t security_id);
static void ps5_l2cap_deinit_service(const char *name, uint16_t psm);
static void ps5_l2cap_connect_ind_cback(BD_ADDR  bd_addr, uint16_t l2cap_cid, uint16_t psm, uint8_t l2cap_id);
static void ps5_l2cap_connect_cfm_cback(uint16_t l2cap_cid, uint16_t result);
static void ps5_l2cap_config_ind_cback(uint16_t l2cap_cid, tL2CAP_CFG_INFO *p_cfg);
static void ps5_l2cap_config_cfm_cback(uint16_t l2cap_cid, tL2CAP_CFG_INFO *p_cfg);
static void ps5_l2cap_disconnect_ind_cback(uint16_t l2cap_cid, bool ack_needed);
static void ps5_l2cap_disconnect_cfm_cback(uint16_t l2cap_cid, uint16_t result);
static void ps5_l2cap_data_ind_cback(uint16_t l2cap_cid, BT_HDR *p_msg);
static void ps5_l2cap_congest_cback(uint16_t cid, bool congested);


/********************************************************************************/
/*                         L O C A L    V A R I A B L E S                       */
/********************************************************************************/

static const tL2CAP_APPL_INFO dyn_info = {
    ps5_l2cap_connect_ind_cback,
    ps5_l2cap_connect_cfm_cback,
    NULL,
    ps5_l2cap_config_ind_cback,
    ps5_l2cap_config_cfm_cback,
    ps5_l2cap_disconnect_ind_cback,
    ps5_l2cap_disconnect_cfm_cback,
    NULL,
    ps5_l2cap_data_ind_cback,
    ps5_l2cap_congest_cback,
    NULL
};

static tL2CAP_CFG_INFO ps5_cfg_info;

bool is_connected = false;
static BD_ADDR g_bd_addr;
uint16_t l2cap_control_channel = 0;
uint16_t l2cap_interrupt_channel = 0;


/********************************************************************************/
/*                      P U B L I C    F U N C T I O N S                        */
/********************************************************************************/

/*******************************************************************************
**
** Function         ps5_l2cap_init_services
**
** Description      This function initialises the required L2CAP services.
**
** Returns          void
**
*******************************************************************************/
void ps5_l2cap_init_services() {
    ps5_l2cap_init_service("ps5-HIDC", BT_PSM_HID_CONTROL, BTM_SEC_SERVICE_FIRST_EMPTY);
    ps5_l2cap_init_service("ps5-HIDI", BT_PSM_HID_INTERRUPT, BTM_SEC_SERVICE_FIRST_EMPTY + 1);
}

/*******************************************************************************
**
** Function         ps5_l2cap_deinit_services
**
** Description      This function deinitialises the required L2CAP services.
**
** Returns          void
**
*******************************************************************************/
void ps5_l2cap_deinit_services() {
    ps5_l2cap_deinit_service("ps5-HIDC", BT_PSM_HID_CONTROL);
    ps5_l2cap_deinit_service("ps5-HIDI", BT_PSM_HID_INTERRUPT);
}

/*******************************************************************************
**
** Function         ps5_l2cap_connect
**
** Description      This function deinitialises the required L2CAP services.
**
** Returns          Result of connection reqiest
**
*******************************************************************************/
long ps5_l2cap_connect(BD_ADDR addr) {
    memmove(g_bd_addr, addr, sizeof(BD_ADDR));

    return ps5_l2cap_reconnect();
}

/*******************************************************************************
**
** Function         ps5_l2cap_reconnect
**
** Description      This function deinitialises the required L2CAP services.
**
** Returns          Result of connection reqiest
**
*******************************************************************************/
long ps5_l2cap_reconnect(void) {
    long ret;
    ret = L2CA_CONNECT_REQ(BT_PSM_HID_CONTROL, g_bd_addr, NULL, NULL);
    ESP_LOGE(ps5_TAG, "L2CA_CONNECT_REQ ret=%d\n", ret);
    if (ret == 0) {
        return -1;
    }
    l2cap_control_channel = ret;

    // is_connected = false;

    return ret;
}


/*******************************************************************************
**
** Function         ps5_l2cap_send_hid
**
** Description      This function sends the HID command using the L2CAP service.
**
** Returns          void
**
*******************************************************************************/
void ps5_l2cap_send_hid( hid_cmd_t *hid_cmd, uint8_t len ) {
    uint8_t result;
    BT_HDR *p_buf;

    p_buf = (BT_HDR *)osi_malloc(BT_DEFAULT_BUFFER_SIZE);

    if (!p_buf) {
        ESP_LOGE(ps5_TAG, "[%s] allocating buffer for sending the command failed", __func__);
    }

    p_buf->length = len + ( sizeof(*hid_cmd) - sizeof(hid_cmd->data) );
    p_buf->offset = L2CAP_MIN_OFFSET;

    memcpy((uint8_t *)(p_buf + 1) + p_buf->offset, (uint8_t*)hid_cmd, p_buf->length);

    if (l2cap_control_channel == 0) {
        ESP_LOGE(ps5_TAG, "[%s] l2cap_control_channel not initialized.", __func__);
    }
    result = L2CA_DataWrite(l2cap_control_channel, p_buf );

    if (result == L2CAP_DW_SUCCESS)
        ESP_LOGI(ps5_TAG, "[%s] sending command: success", __func__);

    if (result == L2CAP_DW_CONGESTED)
        ESP_LOGW(ps5_TAG, "[%s] sending command: congested", __func__);

    if (result == L2CAP_DW_FAILED)
        ESP_LOGE(ps5_TAG, "[%s] sending command: failed", __func__);
}


/********************************************************************************/
/*                      L O C A L    F U N C T I O N S                          */
/********************************************************************************/

/*******************************************************************************
**
** Function         ps5_l2cap_init_service
**
** Description      This registers the specified bluetooth service in order
**                  to listen for incoming connections.
**
** Returns          void
**
*******************************************************************************/
static void ps5_l2cap_init_service(const char *name, uint16_t psm, uint8_t security_id) {
    // log_i("init services");
    /* Register the PSM for incoming connections */
    if (!L2CA_Register(psm, (tL2CAP_APPL_INFO *) &dyn_info)) {
        ESP_LOGE(ps5_TAG, "%s Registering service %s failed", __func__, name);
        return;
    }

    /* Register with the Security Manager for our specific security level (none) */
    if (!BTM_SetSecurityLevel (false, name, security_id, 0, psm, 0, 0)) {
        ESP_LOGE (ps5_TAG, "%s Registering security service %s failed", __func__, name);\
        return;
    }

    ESP_LOGI(ps5_TAG, "[%s] Service %s Initialized", __func__, name);
}

/*******************************************************************************
**
** Function         ps5_l2cap_deinit_service
**
** Description      This deregisters the specified bluetooth service.
**
** Returns          void
**
*******************************************************************************/
static void ps5_l2cap_deinit_service(const char *name, uint16_t psm ) {
    /* Deregister the PSM from incoming connections */
    L2CA_Deregister(psm);
    ESP_LOGI(ps5_TAG, "[%s] Service %s Deinitialized", __func__, name);
}


/*******************************************************************************
**
** Function         ps5_l2cap_connect_ind_cback
**
** Description      This the L2CAP inbound connection indication callback function.
**
** Returns          void
**
*******************************************************************************/
static void ps5_l2cap_connect_ind_cback (BD_ADDR  bd_addr, uint16_t l2cap_cid, uint16_t psm, uint8_t l2cap_id) {
    ESP_LOGI(ps5_TAG, "[%s] bd_addr: %s\n  l2cap_cid: 0x%02x\n  psm: %d\n  id: %d", __func__, bd_addr, l2cap_cid, psm, l2cap_id );

    /* Send connection pending response to the L2CAP layer. */
    L2CA_CONNECT_RSP(bd_addr, l2cap_id, l2cap_cid, L2CAP_CONN_PENDING, L2CAP_CONN_PENDING, NULL, NULL);

    /* Send response to the L2CAP layer. */
    L2CA_CONNECT_RSP(bd_addr, l2cap_id, l2cap_cid, L2CAP_CONN_OK, L2CAP_CONN_OK, NULL, NULL);

    /* Send a Configuration Request. */
    L2CA_CONFIG_REQ(l2cap_cid, &ps5_cfg_info);

    if (psm == BT_PSM_HID_CONTROL) {
        l2cap_control_channel = l2cap_cid;
    } else if (psm == BT_PSM_HID_INTERRUPT) {
        l2cap_interrupt_channel = l2cap_cid;
    }
}


/*******************************************************************************
**
** Function         ps5_l2cap_connect_cfm_cback
**
** Description      This is the L2CAP connect confirmation callback function.
**
**
** Returns          void
**
*******************************************************************************/
static void ps5_l2cap_connect_cfm_cback(uint16_t l2cap_cid, uint16_t result) {
    ESP_LOGI(ps5_TAG, "[%s] l2cap_cid: 0x%02x\n  result: %d", __func__, l2cap_cid, result );
}


/*******************************************************************************
**
** Function         ps5_l2cap_config_cfm_cback
**
** Description      This is the L2CAP config confirmation callback function.
**
**
** Returns          void
**
*******************************************************************************/
void ps5_l2cap_config_cfm_cback(uint16_t l2cap_cid, tL2CAP_CFG_INFO *p_cfg) {
    ESP_LOGI(ps5_TAG, "[%s] l2cap_cid: 0x%02x\n  p_cfg->result: %d", __func__, l2cap_cid, p_cfg->result );

    /* The ps5 controller is connected after    */
    /* receiving the second config confirmation */
    bool prev_is_connected = is_connected;
    is_connected = l2cap_cid == l2cap_interrupt_channel;
    if (prev_is_connected != is_connected) {
        ps5ConnectEvent(is_connected);
    }
}


/*******************************************************************************
**
** Function         ps5_l2cap_config_ind_cback
**
** Description      This is the L2CAP config indication callback function.
**
**
** Returns          void
**
*******************************************************************************/
void ps5_l2cap_config_ind_cback(uint16_t l2cap_cid, tL2CAP_CFG_INFO *p_cfg) {
    ESP_LOGI(ps5_TAG, "[%s] l2cap_cid: 0x%02x\n  p_cfg->result: %d\n  p_cfg->mtu_present: %d\n  p_cfg->mtu: %d", __func__, l2cap_cid, p_cfg->result, p_cfg->mtu_present, p_cfg->mtu );

    p_cfg->result = L2CAP_CFG_OK;

    L2CA_ConfigRsp(l2cap_cid, p_cfg);
}


/*******************************************************************************
**
** Function         ps5_l2cap_disconnect_ind_cback
**
** Description      This is the L2CAP disconnect indication callback function.
**
**
** Returns          void
**
*******************************************************************************/
void ps5_l2cap_disconnect_ind_cback(uint16_t l2cap_cid, bool ack_needed) {
    ESP_LOGI(ps5_TAG, "[%s] l2cap_cid: 0x%02x\n  ack_needed: %d", __func__, l2cap_cid, ack_needed );
    is_connected = false;
    if (ack_needed) {
        L2CA_DisconnectRsp(l2cap_cid);
    }
    ps5ConnectEvent(is_connected);
}


/*******************************************************************************
**
** Function         ps5_l2cap_disconnect_cfm_cback
**
** Description      This is the L2CAP disconnect confirm callback function.
**
**
** Returns          void
**
*******************************************************************************/
static void ps5_l2cap_disconnect_cfm_cback(uint16_t l2cap_cid, uint16_t result) {
    ESP_LOGI(ps5_TAG, "[%s] l2cap_cid: 0x%02x\n  result: %d", __func__, l2cap_cid, result );
}


/*******************************************************************************
**
** Function         ps5_l2cap_data_ind_cback
**
** Description      This is the L2CAP data indication callback function.
**
**
** Returns          void
**
*******************************************************************************/
static void ps5_l2cap_data_ind_cback(uint16_t l2cap_cid, BT_HDR *p_buf) {
    if (p_buf->length > 2) {
        parsePacket(p_buf->data);
    }

    osi_free(p_buf);
}


/*******************************************************************************
**
** Function         ps5_l2cap_congest_cback
**
** Description      This is the L2CAP congestion callback function.
**
** Returns          void
**
*******************************************************************************/
static void ps5_l2cap_congest_cback (uint16_t l2cap_cid, bool congested) {
    ESP_LOGI(ps5_TAG, "[%s] l2cap_cid: 0x%02x\n  congested: %d", __func__, l2cap_cid, congested );
}

================
File: ps5-esp32-main\src\ps5_parser.c
================
#include <esp_system.h>

#include "ps5.h"
#include "ps5_int.h"

/********************************************************************************/
/*                            L O C A L    T Y P E S */
/********************************************************************************/

enum ps5_packet_index {
  packet_index_analog_stick_lx = 11,
  packet_index_analog_stick_ly = 12,
  packet_index_analog_stick_rx = 13,
  packet_index_analog_stick_ry = 14,

  packet_index_button_standard = 15,
  packet_index_button_extra = 16,
  packet_index_button_ps = 17,

  packet_index_analog_l2 = 18,
  packet_index_analog_r2 = 19,

  packet_index_status = 42
};

enum ps5_button_mask {
  button_mask_up = 0,
  button_mask_right = 0b00000010,
  button_mask_down = 0b00000100,
  button_mask_left = 0b00000110,

  button_mask_upright = 0b00000001,
  button_mask_downright = 0b00000011,
  button_mask_upleft = 0b00000111,
  button_mask_downleft = 0b00000101,

  button_mask_direction = 0b00001111,

  button_mask_square = 0b00010000,
  button_mask_cross = 0b00100000,
  button_mask_circle = 0b01000000,
  button_mask_triangle = 0b10000000,

  button_mask_l1 = 0b00000001,
  button_mask_r1 = 0b00000010,
  button_mask_l2 = 0b00000100,
  button_mask_r2 = 0b00001000,

  button_mask_share = 0b00010000,
  button_mask_options = 0b00100000,

  button_mask_l3 = 0b01000000,
  button_mask_r3 = 0b10000000,

  button_mask_ps = 0b01,
  button_mask_touchpad = 0b10
};

enum ps5_status_mask {
  ps5_status_mask_battery = 0b00001111,
  ps5_status_mask_charging = 0b00010000,
  ps5_status_mask_audio = 0b00100000,
  ps5_status_mask_mic = 0b01000000,
};

/********************************************************************************/
/*              L O C A L    F U N C T I O N     P R O T O T Y P E S */
/********************************************************************************/

ps5_sensor_t parsePacketSensor(uint8_t* packet);
ps5_status_t parsePacketStatus(uint8_t* packet);
ps5_analog_stick_t parsePacketAnalogStick(uint8_t* packet);
ps5_analog_button_t parsePacketAnalogButton(uint8_t* packet);
ps5_button_t parsePacketButtons(uint8_t* packet);
ps5_event_t parseEvent(ps5_t prev, ps5_t cur);

/********************************************************************************/
/*                         L O C A L    V A R I A B L E S */
/********************************************************************************/

static ps5_t ps5;
static ps5_event_callback_t ps5_event_cb = NULL;

/********************************************************************************/
/*                      P U B L I C    F U N C T I O N S */
/********************************************************************************/
void parserSetEventCb(ps5_event_callback_t cb) { ps5_event_cb = cb; }

void parsePacket(uint8_t* packet) {
  ps5_t prev_ps5 = ps5;

  ps5.button = parsePacketButtons(packet);
  ps5.analog.stick = parsePacketAnalogStick(packet);
  ps5.analog.button = parsePacketAnalogButton(packet);
  // ps5.sensor = parsePacketSensor(packet);
  ps5.status = parsePacketStatus(packet);
  ps5.latestPacket = packet;

  ps5_event_t ps5Event = parseEvent(prev_ps5, ps5);

  ps5PacketEvent(ps5, ps5Event);
}

/********************************************************************************/
/*                      L O C A L    F U N C T I O N S */
/********************************************************************************/

/******************/
/*    E V E N T   */
/******************/
ps5_event_t parseEvent(ps5_t prev, ps5_t cur) {
  ps5_event_t ps5Event;

  /* Button down events */
  ps5Event.button_down.right = !prev.button.right && cur.button.right;
  ps5Event.button_down.down = !prev.button.down && cur.button.down;
  ps5Event.button_down.up = !prev.button.up && cur.button.up;
  ps5Event.button_down.left = !prev.button.left && cur.button.left;

  ps5Event.button_down.square = !prev.button.square && cur.button.square;
  ps5Event.button_down.cross = !prev.button.cross && cur.button.cross;
  ps5Event.button_down.circle = !prev.button.circle && cur.button.circle;
  ps5Event.button_down.triangle = !prev.button.triangle && cur.button.triangle;

  ps5Event.button_down.upright = !prev.button.upright && cur.button.upright;
  ps5Event.button_down.downright = !prev.button.downright && cur.button.downright;
  ps5Event.button_down.upleft = !prev.button.upleft && cur.button.upleft;
  ps5Event.button_down.downleft = !prev.button.downleft && cur.button.downleft;

  ps5Event.button_down.l1 = !prev.button.l1 && cur.button.l1;
  ps5Event.button_down.r1 = !prev.button.r1 && cur.button.r1;
  ps5Event.button_down.l2 = !prev.button.l2 && cur.button.l2;
  ps5Event.button_down.r2 = !prev.button.r2 && cur.button.r2;

  ps5Event.button_down.share = !prev.button.share && cur.button.share;
  ps5Event.button_down.options = !prev.button.options && cur.button.options;
  ps5Event.button_down.l3 = !prev.button.l3 && cur.button.l3;
  ps5Event.button_down.r3 = !prev.button.r3 && cur.button.r3;

  ps5Event.button_down.ps = !prev.button.ps && cur.button.ps;
  ps5Event.button_down.touchpad = !prev.button.touchpad && cur.button.touchpad;

  /* Button up events */
  ps5Event.button_down.right = prev.button.right && !cur.button.right;
  ps5Event.button_down.down = prev.button.down && !cur.button.down;
  ps5Event.button_down.up = prev.button.up && !cur.button.up;
  ps5Event.button_down.left = prev.button.left && !cur.button.left;

  ps5Event.button_down.square = prev.button.square && !cur.button.square;
  ps5Event.button_down.cross = prev.button.cross && !cur.button.cross;
  ps5Event.button_down.circle = prev.button.circle && !cur.button.circle;
  ps5Event.button_down.triangle = prev.button.triangle && !cur.button.triangle;

  ps5Event.button_down.upright = prev.button.upright && !cur.button.upright;
  ps5Event.button_down.downright = prev.button.downright && !cur.button.downright;
  ps5Event.button_down.upleft = prev.button.upleft && !cur.button.upleft;
  ps5Event.button_down.downleft = prev.button.downleft && !cur.button.downleft;

  ps5Event.button_down.l1 = prev.button.l1 && !cur.button.l1;
  ps5Event.button_down.r1 = prev.button.r1 && !cur.button.r1;
  ps5Event.button_down.l2 = prev.button.l2 && !cur.button.l2;
  ps5Event.button_down.r2 = prev.button.r2 && !cur.button.r2;

  ps5Event.button_down.share = prev.button.share && !cur.button.share;
  ps5Event.button_down.options = prev.button.options && !cur.button.options;
  ps5Event.button_down.l3 = prev.button.l3 && !cur.button.l3;
  ps5Event.button_down.r3 = prev.button.r3 && !cur.button.r3;

  ps5Event.button_down.ps = prev.button.ps && !cur.button.ps;
  ps5Event.button_down.touchpad = prev.button.touchpad && !cur.button.touchpad;

  ps5Event.analog_move.stick.lx = cur.analog.stick.lx != 0;
  ps5Event.analog_move.stick.ly = cur.analog.stick.ly != 0;
  ps5Event.analog_move.stick.rx = cur.analog.stick.rx != 0;
  ps5Event.analog_move.stick.ry = cur.analog.stick.ry != 0;

  return ps5Event;
}

/********************/
/*    A N A L O G   */
/********************/
ps5_analog_stick_t parsePacketAnalogStick(uint8_t* packet) {
  ps5_analog_stick_t ps5AnalogStick;

  const uint8_t offset = 128;

  ps5AnalogStick.lx = packet[packet_index_analog_stick_lx] - offset;
  ps5AnalogStick.ly = -packet[packet_index_analog_stick_ly] + offset - 1;
  ps5AnalogStick.rx = packet[packet_index_analog_stick_rx] - offset;
  ps5AnalogStick.ry = -packet[packet_index_analog_stick_ry] + offset - 1;

  return ps5AnalogStick;
}

ps5_analog_button_t parsePacketAnalogButton(uint8_t* packet) {
  ps5_analog_button_t ps5AnalogButton;

  ps5AnalogButton.l2 = packet[packet_index_analog_l2];
  ps5AnalogButton.r2 = packet[packet_index_analog_r2];

  return ps5AnalogButton;
}

/*********************/
/*   B U T T O N S   */
/*********************/

ps5_button_t parsePacketButtons(uint8_t* packet) {
  ps5_button_t ps5_button;
  uint8_t frontBtnData = packet[packet_index_button_standard];
  uint8_t extraBtnData = packet[packet_index_button_extra];
  uint8_t psBtnData = packet[packet_index_button_ps];
  uint8_t directionBtnsOnly = button_mask_direction & frontBtnData;

  ps5_button.up = directionBtnsOnly == button_mask_up;
  ps5_button.right = directionBtnsOnly == button_mask_right;
  ps5_button.down = directionBtnsOnly == button_mask_down;
  ps5_button.left = directionBtnsOnly == button_mask_left;

  ps5_button.upright = directionBtnsOnly == button_mask_upright;
  ps5_button.upleft = directionBtnsOnly == button_mask_upleft;
  ps5_button.downright = directionBtnsOnly == button_mask_downright;
  ps5_button.downleft = directionBtnsOnly == button_mask_downleft;

  ps5_button.triangle = (frontBtnData & button_mask_triangle) ? true : false;
  ps5_button.circle = (frontBtnData & button_mask_circle) ? true : false;
  ps5_button.cross = (frontBtnData & button_mask_cross) ? true : false;
  ps5_button.square = (frontBtnData & button_mask_square) ? true : false;

  ps5_button.l1 = (extraBtnData & button_mask_l1) ? true : false;
  ps5_button.r1 = (extraBtnData & button_mask_r1) ? true : false;
  ps5_button.l2 = (extraBtnData & button_mask_l2) ? true : false;
  ps5_button.r2 = (extraBtnData & button_mask_r2) ? true : false;

  ps5_button.share = (extraBtnData & button_mask_share) ? true : false;
  ps5_button.options = (extraBtnData & button_mask_options) ? true : false;
  ps5_button.l3 = (extraBtnData & button_mask_l3) ? true : false;
  ps5_button.r3 = (extraBtnData & button_mask_r3) ? true : false;

  ps5_button.ps = (psBtnData & button_mask_ps) ? true : false;
  ps5_button.touchpad = (psBtnData & button_mask_touchpad) ? true : false;

  return ps5_button;
}

/*******************************/
/*   S T A T U S   F L A G S   */
/*******************************/
ps5_status_t parsePacketStatus(uint8_t* packet) {
  ps5_status_t ps5Status;

  ps5Status.battery = packet[packet_index_status] & ps5_status_mask_battery;
  ps5Status.charging = packet[packet_index_status] & ps5_status_mask_charging ? true : false;
  ps5Status.audio = packet[packet_index_status] & ps5_status_mask_audio ? true : false;
  ps5Status.mic = packet[packet_index_status] & ps5_status_mask_mic ? true : false;

  return ps5Status;
}

/********************/
/*   S E N S O R S  */
/********************/
ps5_sensor_t parsePacketSensor(uint8_t* packet) {
  ps5_sensor_t ps5Sensor;
  /*
      const uint16_t offset = 0x200;

      ps5Sensor.accelerometer.x = (packet[packet_index_sensor_accelerometer_x] << 8) +
     packet[packet_index_sensor_accelerometer_x+1] - offset;
      ps5Sensor.accelerometer.y = (packet[packet_index_sensor_accelerometer_y] << 8) +
     packet[packet_index_sensor_accelerometer_y+1] - offset;
      ps5Sensor.accelerometer.z = (packet[packet_index_sensor_accelerometer_z] << 8) +
     packet[packet_index_sensor_accelerometer_z+1] - offset;
      ps5Sensor.gyroscope.z     = (packet[packet_index_sensor_gyroscope_z]
     << 8) + packet[packet_index_sensor_gyroscope_z+1]     - offset;
  */
  return ps5Sensor;
}

================
File: ps5-esp32-main\src\ps5_spp.c
================
#include "esp_bt.h"
#include "esp_bt_device.h"
#include "esp_bt_main.h"
#include "esp_gap_bt_api.h"
#include "esp_log.h"
#include "esp_spp_api.h"
#include "ps5.h"
#include "ps5_int.h"

#define ps5_TAG "ps5_SPP"

/********************************************************************************/
/*              L O C A L    F U N C T I O N     P R O T O T Y P E S            */
/********************************************************************************/
static void sppCallback(esp_spp_cb_event_t event, esp_spp_cb_param_t* param);

/********************************************************************************/
/*                      P U B L I C    F U N C T I O N S                        */
/********************************************************************************/

/*******************************************************************************
**
** Function         sppInit
**
** Description      Initialise the SPP server to allow to be connected to
**
** Returns          void
**
*******************************************************************************/
void sppInit() {
  esp_err_t ret;

#ifndef ARDUINO_ARCH_ESP32
  esp_bt_controller_config_t bt_cfg = BT_CONTROLLER_INIT_CONFIG_DEFAULT();
  if ((ret = esp_bt_controller_init(&bt_cfg)) != ESP_OK) {
    ESP_LOGE(ps5_TAG, "%s initialize controller failed: %s\n", __func__, esp_err_to_name(ret));
    return;
  }

  if ((ret = esp_bt_controller_enable(BT_MODE)) != ESP_OK) {
    ESP_LOGE(ps5_TAG, "%s enable controller failed: %s\n", __func__, esp_err_to_name(ret));
    return;
  }

  if ((ret = esp_bluedroid_init()) != ESP_OK) {
    ESP_LOGE(ps5_TAG, "%s initialize bluedroid failed: %s\n", __func__, esp_err_to_name(ret));
    return;
  }

  if ((ret = esp_bluedroid_enable()) != ESP_OK) {
    ESP_LOGE(ps5_TAG, "%s enable bluedroid failed: %s\n", __func__, esp_err_to_name(ret));
    return;
  }
#endif

  if ((ret = esp_spp_register_callback(sppCallback)) != ESP_OK) {
    ESP_LOGE(ps5_TAG, "%s spp register failed: %s\n", __func__, esp_err_to_name(ret));
    return;
  }

  if ((ret = esp_spp_init(ESP_SPP_MODE_CB)) != ESP_OK) {
    ESP_LOGE(ps5_TAG, "%s spp init failed: %s\n", __func__, esp_err_to_name(ret));
    return;
  }
}

/********************************************************************************/
/*                      L O C A L    F U N C T I O N S                          */
/********************************************************************************/

/*******************************************************************************
**
** Function         sppCallback
**
** Description      Callback for SPP events, only used for the init event to
**                  configure the SPP server
**
** Returns          void
**
*******************************************************************************/
static void sppCallback(esp_spp_cb_event_t event, esp_spp_cb_param_t* param) {
  if (event == ESP_SPP_INIT_EVT) {
    ESP_LOGI(ps5_TAG, "ESP_SPP_INIT_EVT");

#if ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 0, 0)
        esp_bt_gap_set_scan_mode(ESP_BT_CONNECTABLE, ESP_BT_NON_DISCOVERABLE);
#else
        esp_bt_gap_set_scan_mode(ESP_BT_SCAN_MODE_CONNECTABLE);
#endif
  }
}

================
File: ps5-esp32-main\src\osi\allocator.h
================
/******************************************************************************
 *
 *  Copyright (C) 2014 Google, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at:
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 ******************************************************************************/

#ifndef _ALLOCATOR_H_
#define _ALLOCATOR_H_

#include <stddef.h>
#include <stdlib.h>
#include "esp_heap_caps.h"

char *osi_strdup(const char *str);

void *osi_malloc_func(size_t size);
void *osi_calloc_func(size_t size);
void osi_free_func(void *ptr);

#if HEAP_MEMORY_DEBUG

void osi_mem_dbg_init(void);
void osi_mem_dbg_record(void *p, int size, const char *func, int line);
void osi_mem_dbg_clean(void *p, const char *func, int line);
void osi_mem_dbg_show(void);
uint32_t osi_mem_dbg_get_max_size(void);
uint32_t osi_mem_dbg_get_current_size(void);
void osi_men_dbg_set_section_start(uint8_t index);
void osi_men_dbg_set_section_end(uint8_t index);
uint32_t osi_mem_dbg_get_max_size_section(uint8_t index);

#if HEAP_ALLOCATION_FROM_SPIRAM_FIRST
#define osi_malloc(size)                                \
({                                                      \
    void *p;                                            \
    p = heap_caps_malloc_prefer(size, 2,                \
        MALLOC_CAP_DEFAULT|MALLOC_CAP_SPIRAM,           \
        MALLOC_CAP_DEFAULT|MALLOC_CAP_INTERNAL);        \
    osi_mem_dbg_record(p, size, __func__, __LINE__);    \
    (void *)p;                                          \
})

#define osi_calloc(size)                                \
({                                                      \
    void *p;                                            \
    p = heap_caps_calloc_prefer(1, size, 2,             \
        MALLOC_CAP_DEFAULT|MALLOC_CAP_SPIRAM,           \
        MALLOC_CAP_DEFAULT|MALLOC_CAP_INTERNAL);        \
    osi_mem_dbg_record(p, size, __func__, __LINE__);    \
    (void *)p;                                          \
})

#else

#define osi_malloc(size)                                \
({                                                      \
    void *p;                                            \
    p = malloc((size));                                 \
    osi_mem_dbg_record(p, size, __func__, __LINE__);    \
    (void *)p;                                          \
})

#define osi_calloc(size)                                \
({                                                      \
    void *p;                                            \
    p = calloc(1, (size));                              \
    osi_mem_dbg_record(p, size, __func__, __LINE__);    \
    (void *)p;                                          \
})

#endif /* #if HEAP_ALLOCATION_FROM_SPIRAM_FIRST */


#if 0
#define osi_malloc(size)                                \
do {                                                    \
    void *p;                                            \
                                                        \
#if HEAP_ALLOCATION_FROM_SPIRAM_FIRST              \
    p = heap_caps_malloc_prefer(size, 2, MALLOC_CAP_DEFAULT|MALLOC_CAP_SPIRAM, MALLOC_CAP_DEFAULT|MALLOC_CAP_INTERNAL); \
#else                                                   \
    p = malloc((size));                                 \
#endif /* #if HEAP_ALLOCATION_FROM_SPIRAM_FIRST */ \
    osi_mem_dbg_record(p, size, __func__, __LINE__);    \
    (void *)p;                                          \
}while(0)

#define osi_calloc(size)                                \
do {                                                    \
    void *p;                                            \
                                                        \
#if HEAP_ALLOCATION_FROM_SPIRAM_FIRST              \
        p = heap_caps_calloc_prefer(1, size, 2,         \
            MALLOC_CAP_DEFAULT|MALLOC_CAP_SPIRAM,       \
            MALLOC_CAP_DEFAULT|MALLOC_CAP_INTERNAL);    \
#else                                                   \
    p = calloc(1, (size));                              \
#endif /* #if HEAP_ALLOCATION_FROM_SPIRAM_FIRST */ \
    osi_mem_dbg_record(p, size, __func__, __LINE__);    \
    (void *)p;                                          \
} while(0)
#endif

#define osi_free(ptr)                                   \
do {                                                    \
    void *tmp_point = (void *)(ptr);                    \
    osi_mem_dbg_clean(tmp_point, __func__, __LINE__);   \
    free(tmp_point);                                    \
} while (0)

#else

#if HEAP_ALLOCATION_FROM_SPIRAM_FIRST
#define osi_malloc(size)                  heap_caps_malloc_prefer(size, 2, MALLOC_CAP_DEFAULT|MALLOC_CAP_SPIRAM, MALLOC_CAP_DEFAULT|MALLOC_CAP_INTERNAL)
#define osi_calloc(size)                  heap_caps_calloc_prefer(1, size, 2, MALLOC_CAP_DEFAULT|MALLOC_CAP_SPIRAM, MALLOC_CAP_DEFAULT|MALLOC_CAP_INTERNAL)
#else
#define osi_malloc(size)                  malloc((size))
#define osi_calloc(size)                  calloc(1, (size))
#endif /* #if HEAP_ALLOCATION_FROM_SPIRAM_FIRST */
#define osi_free(p)                       free((p))

#endif /* HEAP_MEMORY_DEBUG */

#define FREE_AND_RESET(a)   \
do {                        \
    if (a) {                \
        osi_free(a);        \
        a = NULL;           \
    }                       \
}while (0)


#endif /* _ALLOCATOR_H_ */

================
File: ps5-esp32-main\src\stack\btm_api.h
================
/******************************************************************************
 *
 *  Copyright (C) 1999-2012 Broadcom Corporation
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at:
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 ******************************************************************************/

/******************************************************************************
 *
 *  This file contains the Bluetooth Manager (BTM) API function external
 *  definitions.
 *
 ******************************************************************************/
#ifndef BTM_API_H
#define BTM_API_H


#include "stack/bt_types.h"

/* Security service definitions (BTM_SetSecurityLevel)
** Used for Authorization APIs
*/

/* Update these as services are added */
#define BTM_SEC_SERVICE_FIRST_EMPTY     51

#define BT_DEFAULT_BUFFER_SIZE (4096 + 16)

#ifndef BTM_SEC_MAX_SERVICES
#define BTM_SEC_MAX_SERVICES            65
#endif


/*******************************************************************************
**
** Function         BTM_SetSecurityLevel
**
** Description      Register service security level with Security Manager.  Each
**                  service must register its requirements regardless of the
**                  security level that is used.  This API is called once for originators
**                  nad again for acceptors of connections.
**
** Returns          TRUE if registered OK, else FALSE
**
*******************************************************************************/
//extern
bool BTM_SetSecurityLevel (bool is_originator, const char *p_name,
                              uint8_t service_id, uint16_t sec_level,
                              uint16_t psm, uint32_t mx_proto_id,
                              uint32_t mx_chan_id);

#endif /* BTM_API_H */

================
File: ps5-esp32-main\src\stack\bt_types.h
================
/******************************************************************************
 *
 *  Copyright (C) 1999-2012 Broadcom Corporation
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at:
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 ******************************************************************************/

#ifndef BT_TYPES_H
#define BT_TYPES_H

#include <stdbool.h>
#include <stdint.h>

// typedef uint8_t UINT8;
// typedef uint16_t UINT16;
// typedef uint32_t UINT32;
// typedef uint64_t UINT64;

// typedef int8_t INT8;
// typedef int16_t INT16;
// typedef int32_t INT32;
// typedef bool BOOLEAN;

/* Define the header of each buffer used in the Bluetooth stack.
 */
typedef struct {
  uint16_t event;
  uint16_t length;
  uint16_t offset;
  uint16_t layer_specific;
  uint8_t data[];
} BT_HDR;

#define BT_PSM_HID_CONTROL 0x0011
#define BT_PSM_HID_INTERRUPT 0x0013

typedef struct {
  uint8_t qos_flags;          /* TBD */
  uint8_t service_type;       /* see below */
  uint32_t token_rate;        /* bytes/second */
  uint32_t token_bucket_size; /* bytes */
  uint32_t peak_bandwidth;    /* bytes/second */
  uint32_t latency;           /* microseconds */
  uint32_t delay_variation;   /* microseconds */
} FLOW_SPEC;

/* bd addr length and type */
#ifndef BD_ADDR_LEN
#define BD_ADDR_LEN 6
typedef uint8_t BD_ADDR[BD_ADDR_LEN];
#endif

#endif

================
File: ps5-esp32-main\src\stack\gap_api.h
================
#ifndef GAP_API_H
#define GAP_API_H

#include "stack/l2c_api.h"

/*****************************************************************************
**  Constants
*****************************************************************************/
/*** GAP Error and Status Codes ***/
#define GAP_EVT_CONN_OPENED 0x0100
#define GAP_EVT_CONN_CLOSED 0x0101
#define GAP_EVT_CONN_DATA_AVAIL 0x0102
#define GAP_EVT_CONN_CONGESTED 0x0103
#define GAP_EVT_CONN_UNCONGESTED 0x01043

/*** used in connection variables and functions ***/
#define GAP_INVALID_HANDLE 0xFFFF

/*** Used for general successful function returns ***/
#define BT_PASS 0

/*****************************************************************************
**  Type Definitions
*****************************************************************************/
/*
** Callback function for connection services
*/
typedef void(tGAP_CONN_CALLBACK)(uint16_t gap_handle, uint16_t event);

/*****************************************************************************
**  External Function Declarations
*****************************************************************************/

/*** Functions for L2CAP connection interface ***/

/*******************************************************************************
**
** Function         GAP_ConnOpen
**
** Description      This function is called to open a generic L2CAP connection.
**
** Returns          handle of the connection if successful, else GAP_INVALID_HANDLE
**
*******************************************************************************/
extern uint16_t GAP_ConnOpen(const char* p_serv_name, uint8_t service_id, bool is_server, BD_ADDR p_rem_bda,
  uint16_t psm, tL2CAP_CFG_INFO* p_cfg, tL2CAP_ERTM_INFO* ertm_info, uint16_t security, uint8_t chan_mode_mask,
  tGAP_CONN_CALLBACK* p_cb);

/*******************************************************************************
**
** Function         GAP_ConnClose
**
** Description      This function is called to close a connection.
**
** Returns          BT_PASS             - closed OK
**                  GAP_ERR_BAD_HANDLE  - invalid handle
**
*******************************************************************************/
extern uint16_t GAP_ConnClose(uint16_t gap_handle);

/*******************************************************************************
**
** Function         GAP_ConnBTRead
**
** Description      GKI buffer aware applications will call this function after
**                  receiving an GAP_EVT_RXDATA event to process the incoming
**                  data buffer.
**
** Returns          BT_PASS             - data read
**                  GAP_ERR_BAD_HANDLE  - invalid handle
**                  GAP_NO_DATA_AVAIL   - no data available
**
*******************************************************************************/
extern uint16_t GAP_ConnBTRead(uint16_t gap_handle, BT_HDR** pp_buf);

/*******************************************************************************
**
** Function         GAP_ConnBTWrite
**
** Description      GKI buffer aware applications can call this function to write data
**                  by passing a pointer to the GKI buffer of data.
**
** Returns          BT_PASS                 - data read
**                  GAP_ERR_BAD_HANDLE      - invalid handle
**                  GAP_ERR_BAD_STATE       - connection not established
**                  GAP_INVALID_BUF_OFFSET  - buffer offset is invalid
*******************************************************************************/
extern uint16_t GAP_ConnBTWrite(uint16_t gap_handle, BT_HDR* p_buf);

/*******************************************************************************
**
** Function         GAP_ConnGetL2CAPCid
**
** Description      Returns the L2CAP channel id
**
** Parameters:      handle      - Handle of the connection
**
** Returns          uint16_t      - The L2CAP channel id
**                  0, if error
**
*******************************************************************************/
extern uint16_t GAP_ConnGetL2CAPCid(uint16_t gap_handle);

#endif /* GAP_API_H */

================
File: ps5-esp32-main\src\stack\hcidefs.h
================
#ifndef HCIDEFS_H
#define HCIDEFS_H

#include "stack/bt_types.h"

/* Define the extended flow specification fields used by AMP */
typedef struct {
  uint8_t id;
  uint8_t stype;
  uint16_t max_sdu_size;
  uint32_t sdu_inter_time;
  uint32_t access_latency;
  uint32_t flush_timeout;
} tHCI_EXT_FLOW_SPEC;

#endif

================
File: ps5-esp32-main\src\stack\l2cdefs.h
================
/******************************************************************************
 *
 *  Copyright (C) 1999-2012 Broadcom Corporation
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at:
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 ******************************************************************************/

#ifndef L2CDEFS_H
#define L2CDEFS_H

/* Define the L2CAP connection result codes
*/
#define L2CAP_CONN_OK                0
#define L2CAP_CONN_PENDING           1
#define L2CAP_CONN_NO_PSM            2
#define L2CAP_CONN_SECURITY_BLOCK    3
#define L2CAP_CONN_NO_RESOURCES      4
#define L2CAP_CONN_BAD_CTLR_ID       5              /* AMP related */
#define L2CAP_CONN_TIMEOUT           0xEEEE
#define L2CAP_CONN_AMP_FAILED        254
#define L2CAP_CONN_NO_LINK           255        /* Add a couple of our own for internal use */
#define L2CAP_CONN_CANCEL            256        /* L2CAP connection cancelled */


/* Define the L2CAP configuration result codes
*/
#define L2CAP_CFG_OK                    0
#define L2CAP_CFG_UNACCEPTABLE_PARAMS   1
#define L2CAP_CFG_FAILED_NO_REASON      2
#define L2CAP_CFG_UNKNOWN_OPTIONS       3
#define L2CAP_CFG_PENDING               4
#define L2CAP_CFG_FLOW_SPEC_REJECTED    5

#endif

================
File: ps5-esp32-main\src\stack\l2c_api.h
================
/******************************************************************************
 *
 *  Copyright (C) 1999-2012 Broadcom Corporation
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at:
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 ******************************************************************************/

/******************************************************************************
 *
 *  this file contains the L2CAP API definitions
 *
 ******************************************************************************/
#ifndef L2C_API_H
#define L2C_API_H

#include <stdbool.h>

#include "stack/l2cdefs.h"
#include "stack/hcidefs.h"
#include "stack/btm_api.h"

/*****************************************************************************
**  Constants
*****************************************************************************/

/* Define the minimum offset that L2CAP needs in a buffer. This is made up of
** HCI type(1), len(2), handle(2), L2CAP len(2) and CID(2) => 9
*/
#define L2CAP_MIN_OFFSET 13 /* plus control(2), SDU length(2) */

/* result code for L2CA_DataWrite() */
#define L2CAP_DW_FAILED        false
#define L2CAP_DW_SUCCESS       true
#define L2CAP_DW_CONGESTED     2


/*****************************************************************************
**  Type Definitions
*****************************************************************************/

typedef struct {
#define L2CAP_FCR_BASIC_MODE    0x00
#define L2CAP_FCR_ERTM_MODE     0x03
#define L2CAP_FCR_STREAM_MODE   0x04

  uint8_t mode;

  uint8_t tx_win_sz;
  uint8_t max_transmit;
  uint16_t rtrans_tout;
  uint16_t mon_tout;
  uint16_t mps;
} tL2CAP_FCR_OPTS;

/* Define a structure to hold the configuration parameters. Since the
** parameters are optional, for each parameter there is a boolean to
** use to signify its presence or absence.
*/
typedef struct {
  uint16_t result; /* Only used in confirm messages */
  bool mtu_present;
  uint16_t mtu;
  bool qos_present;
  FLOW_SPEC qos;
  bool flush_to_present;
  uint16_t flush_to;
  bool fcr_present;
  tL2CAP_FCR_OPTS fcr;
  bool fcs_present; /* Optionally bypasses FCS checks */
  uint8_t fcs;      /* '0' if desire is to bypass FCS, otherwise '1' */
  bool ext_flow_spec_present;
  tHCI_EXT_FLOW_SPEC ext_flow_spec;
  uint16_t flags; /* bit 0: 0-no continuation, 1-continuation */
} tL2CAP_CFG_INFO;


/*********************************
**  Callback Functions Prototypes
**********************************/

/* Connection indication callback prototype. Parameters are
**              BD Address of remote
**              Local CID assigned to the connection
**              PSM that the remote wants to connect to
**              Identifier that the remote sent
*/
typedef void (tL2CA_CONNECT_IND_CB) (BD_ADDR, uint16_t, uint16_t, uint8_t);


/* Connection confirmation callback prototype. Parameters are
**              Local CID
**              Result - 0 = connected, non-zero means failure reason
*/
typedef void (tL2CA_CONNECT_CFM_CB) (uint16_t, uint16_t);


/* Connection pending callback prototype. Parameters are
**              Local CID
*/
typedef void (tL2CA_CONNECT_PND_CB) (uint16_t);


/* Configuration indication callback prototype. Parameters are
**              Local CID assigned to the connection
**              Pointer to configuration info
*/
typedef void (tL2CA_CONFIG_IND_CB) (uint16_t, tL2CAP_CFG_INFO *);


/* Configuration confirm callback prototype. Parameters are
**              Local CID assigned to the connection
**              Pointer to configuration info
*/
typedef void (tL2CA_CONFIG_CFM_CB) (uint16_t, tL2CAP_CFG_INFO *);


/* Disconnect indication callback prototype. Parameters are
**              Local CID
**              bool whether upper layer should ack this
*/
typedef void (tL2CA_DISCONNECT_IND_CB) (uint16_t, bool);


/* Disconnect confirm callback prototype. Parameters are
**              Local CID
**              Result
*/
typedef void (tL2CA_DISCONNECT_CFM_CB) (uint16_t, uint16_t);


/* QOS Violation indication callback prototype. Parameters are
**              BD Address of violating device
*/
typedef void (tL2CA_QOS_VIOLATION_IND_CB) (BD_ADDR);


/* Data received indication callback prototype. Parameters are
**              Local CID
**              Address of buffer
*/
typedef void (tL2CA_DATA_IND_CB) (uint16_t, BT_HDR *);


/* Congestion status callback protype. This callback is optional. If
** an application tries to send data when the transmit queue is full,
** the data will anyways be dropped. The parameter is:
**              Local CID
**              TRUE if congested, FALSE if uncongested
*/
typedef void (tL2CA_CONGESTION_STATUS_CB) (uint16_t, bool);


/* Transmit complete callback protype. This callback is optional. If
** set, L2CAP will call it when packets are sent or flushed. If the
** count is 0xFFFF, it means all packets are sent for that CID (eRTM
** mode only). The parameters are:
**              Local CID
**              Number of SDUs sent or dropped
*/
typedef void (tL2CA_TX_COMPLETE_CB) (uint16_t, uint16_t);


/* Define the structure that applications use to register with
** L2CAP. This structure includes callback functions. All functions
** MUST be provided, with the exception of the "connect pending"
** callback and "congestion status" callback.
*/
typedef struct {
    tL2CA_CONNECT_IND_CB        *pL2CA_ConnectInd_Cb;
    tL2CA_CONNECT_CFM_CB        *pL2CA_ConnectCfm_Cb;
    tL2CA_CONNECT_PND_CB        *pL2CA_ConnectPnd_Cb;
    tL2CA_CONFIG_IND_CB         *pL2CA_ConfigInd_Cb;
    tL2CA_CONFIG_CFM_CB         *pL2CA_ConfigCfm_Cb;
    tL2CA_DISCONNECT_IND_CB     *pL2CA_DisconnectInd_Cb;
    tL2CA_DISCONNECT_CFM_CB     *pL2CA_DisconnectCfm_Cb;
    tL2CA_QOS_VIOLATION_IND_CB  *pL2CA_QoSViolationInd_Cb;
    tL2CA_DATA_IND_CB           *pL2CA_DataInd_Cb;
    tL2CA_CONGESTION_STATUS_CB  *pL2CA_CongestionStatus_Cb;
    tL2CA_TX_COMPLETE_CB        *pL2CA_TxComplete_Cb;

} tL2CAP_APPL_INFO;

/* Define the structure that applications use to create or accept
** connections with enhanced retransmission mode.
*/
typedef struct {
    uint8_t       preferred_mode;
    uint8_t       allowed_modes;
    uint16_t      user_rx_buf_size;
    uint16_t      user_tx_buf_size;
    uint16_t      fcr_rx_buf_size;
    uint16_t      fcr_tx_buf_size;

} tL2CAP_ERTM_INFO;

#define L2CA_REGISTER(a,b,c)        L2CA_Register(a,(tL2CAP_APPL_INFO *)b)
#define L2CA_DEREGISTER(a)          L2CA_Deregister(a)
#define L2CA_CONNECT_REQ(a,b,c,d)   L2CA_ErtmConnectReq(a,b,c)
#define L2CA_CONNECT_RSP(a,b,c,d,e,f,g) L2CA_ErtmConnectRsp(a,b,c,d,e,f)
#define L2CA_CONFIG_REQ(a,b)        L2CA_ConfigReq(a,b)
#define L2CA_CONFIG_RSP(a,b)        L2CA_ConfigRsp(a,b)
#define L2CA_DISCONNECT_REQ(a)      L2CA_DisconnectReq(a)
#define L2CA_DISCONNECT_RSP(a)      L2CA_DisconnectRsp(a)
#define L2CA_DATA_WRITE(a, b)       L2CA_DataWrite(a, b)

/*****************************************************************************
**  External Function Declarations
*****************************************************************************/
#ifdef __cplusplus
extern "C"
{
#endif

/*******************************************************************************
**
** Function         L2CA_Register
**
** Description      Other layers call this function to register for L2CAP
**                  services.
**
** Returns          PSM to use or zero if error. Typically, the PSM returned
**                  is the same as was passed in, but for an outgoing-only
**                  connection to a dynamic PSM, a "virtual" PSM is returned
**                  and should be used in the calls to L2CA_ConnectReq() and
**                  BTM_SetSecurityLevel().
**
*******************************************************************************/
extern uint16_t L2CA_Register (uint16_t psm, tL2CAP_APPL_INFO *p_cb_info);

/*******************************************************************************
**
** Function         L2CA_Deregister
**
** Description      Other layers call this function to deregister for L2CAP
**                  services.
**
** Returns          void
**
*******************************************************************************/
extern void L2CA_Deregister (uint16_t psm);

/*******************************************************************************
**
** Function         L2CA_ErtmConnectReq
**
** Description      Higher layers call this function to create an L2CAP connection
**                  that needs to use Enhanced Retransmission Mode.
**                  Note that the connection is not established at this time, but
**                  connection establishment gets started. The callback function
**                  will be invoked when connection establishes or fails.
**
** Returns          the CID of the connection, or 0 if it failed to start
**
*******************************************************************************/
extern uint16_t L2CA_ErtmConnectReq (uint16_t psm, BD_ADDR p_bd_addr,
                                   tL2CAP_ERTM_INFO *p_ertm_info);

/*******************************************************************************
**
** Function         L2CA_ErtmConnectRsp
**
** Description      Higher layers call this function to accept an incoming
**                  L2CAP connection, for which they had gotten an connect
**                  indication callback, and for which the higher layer wants
**                  to use Enhanced Retransmission Mode.
**
** Returns          TRUE for success, FALSE for failure
**
*******************************************************************************/
extern bool  L2CA_ErtmConnectRsp (BD_ADDR p_bd_addr, uint8_t id, uint16_t lcid,
                                     uint16_t result, uint16_t status,
                                     tL2CAP_ERTM_INFO *p_ertm_info);

/*******************************************************************************
**
** Function         L2CA_ConfigReq
**
** Description      Higher layers call this function to send configuration.
**
** Returns          TRUE if configuration sent, else FALSE
**
*******************************************************************************/
extern bool L2CA_ConfigReq (uint16_t cid, tL2CAP_CFG_INFO *p_cfg);

/*******************************************************************************
**
** Function         L2CA_ConfigRsp
**
** Description      Higher layers call this function to send a configuration
**                  response.
**
** Returns          TRUE if configuration response sent, else FALSE
**
*******************************************************************************/
extern bool L2CA_ConfigRsp (uint16_t cid, tL2CAP_CFG_INFO *p_cfg);

/*******************************************************************************
**
** Function         L2CA_DisconnectReq
**
** Description      Higher layers call this function to disconnect a channel.
**
** Returns          TRUE if disconnect sent, else FALSE
**
*******************************************************************************/
extern bool L2CA_DisconnectReq (uint16_t cid);

/*******************************************************************************
**
** Function         L2CA_DisconnectRsp
**
** Description      Higher layers call this function to acknowledge the
**                  disconnection of a channel.
**
** Returns          void
**
*******************************************************************************/
extern bool L2CA_DisconnectRsp (uint16_t cid);

/*******************************************************************************
**
** Function         L2CA_DataWrite
**
** Description      Higher layers call this function to write data.
**
** Returns          L2CAP_DW_SUCCESS, if data accepted, else FALSE
**                  L2CAP_DW_CONGESTED, if data accepted and the channel is congested
**                  L2CAP_DW_FAILED, if error
**
*******************************************************************************/
extern uint8_t L2CA_DataWrite (uint16_t cid, BT_HDR *p_data);


#ifdef __cplusplus
}
#endif

#endif  /* L2C_API_H */

================
File: README.md
================
# HoverCar

This repository showcases an electric “HoverCar” project, built by repurposing two hoverboards and integrating them with custom electronics and firmware. **Disclaimer:** The code in this repo is tailored to my personal setup. While you can explore or reuse parts of it, please note that it was never designed to be a general plug-and-play solution.

## Table of Contents
1. [Project Overview](#project-overview)
2. [Background and Motivation](#background-and-motivation)
3. [Initial Experiments: The Zeus Car](#initial-experiments-the-zeus-car)
4. [Scaling Up: Tank Chassis](#scaling-up-tank-chassis)
5. [Final Stage: The HoverCar](#final-stage-the-hovercar)
6. [Electronics & Components](#electronics--components)
7. [Software & Control](#software--control)
8. [Future Plans](#future-plans)
9. [Acknowledgements](#acknowledgements)

---

## Project Overview

The **HoverCar** began as a quest to build something bigger and more functional than standard hobbyist robot kits. After experimenting with small cars and tank chassis, I moved on to repurposing hoverboard parts due to their powerful motors, controllers, and batteries—all available at a relatively low cost on the secondhand market.

> **Key takeaway:** The knowledge I gained from smaller projects (Zeus car and tank chassis) carried over to this large-scale build, though I still encountered unexpected challenges in firmware flashing, wiring, signal conversion, and more.

![HoverCar test drive](./Images/HoverCar_test_gif.gif)

## Background and Motivation

I'm a student of cybernetics and robotics who loves building practical projects to supplement theoretical knowledge. This project is a playground to learn more about motor control, firmware development, sensor integration, and wireless communication—while also having a blast driving around on a custom electric vehicle.

## Initial Experiments: The Zeus Car

I started with a mini-robot known as the **Zeus Car**, which came as a complete kit: battery, wheels, sensors, and an Arduino UNO R3.

- **Sensors** included: grayscale, camera, ultrasound, etc.
- **Customization:** I replaced the default app control with my own Python script, allowing me to drive it via a PS5 controller (using libraries like `pygame`).
- **Goal:** Learn how to manipulate sensor data and motor output in real-time. I succeeded in reading sensor data on my computer while controlling the car.
- **Limitations:** The motors (5V) couldn’t carry any significant load, but the project was a great introduction to microcontroller basics (PWM signals, RX/TX communication, battery management, and general wiring).

> **Base Zeus Car:** ![Zeus Car base](./Images/ZeusCar.jpeg)

## Scaling Up: Tank Chassis

Next, I bought a **tank chassis** equipped with 12V motors. This allowed me to explore more powerful driver components.

- **Motor drivers:** Two BTS7960 drivers to interface between the Arduino’s 5V PWM signals and the 12V supply.
- **Challenges:**
  - Interpreting the datasheet for correct wiring.
  - **Crucial Lesson:** A common ground (GND) is absolutely necessary.
  - Lots of soldering and troubleshooting to ensure the motor drivers responded correctly.

> **Tank Chassis Test Drive** ![Tank test drive](./Images/Tank_gif.gif)

## Final Stage: The HoverCar

The leap from a tank chassis to a hoverboard-based design wasn’t trivial, but most of the microcontroller logic was transferable:

1. **Sourcing Hoverboards:** Found two used hoverboards for under $30 each. Their motors and built-in motor controllers were ideal, but were typically locked behind proprietary firmware.
2. **Firmware Flashing:**
   - Successfully flashed custom firmware on one hoverboard controller.
   - Had issues flashing the second, so I purchased two generic brushless motor controllers (18–55V) off AliExpress.
3. **Potentiometer vs. UART:**
   - The new controllers were potentiometer-based.
   - I needed an **Arduino Mega** for multiple UART (RX/TX) pins because each hoverboard side needed its own communication channel.
   - **DAC Setup:** The controllers expected analog signals, so I needed a digital-to-analog converter to transform PWM output into a smooth analog voltage.
   - I wrestled with address conflicts, soldering missteps, and code adjustments before getting stable motor control.
4. **Wireless Control with ESP32:**
   - I wanted to drive the HoverCar wirelessly via a PS5 controller.
   - Used an **ESP32** for Bluetooth, referencing open-source libraries and examples.
   - Forwarded the controller inputs to the Arduino for the final motor commands.

> **Pot-based ESC** ![Pot-based ESC](./Images/Pot_based_ESC.jpeg)

> **HoverCar build process** ![HoverCar build process](./Images/Hovercar_build_setup.jpeg)

### Frame and Finishing Touches

- **Frame Construction:** Used wooden planks for a base, adding some basic weatherproofing.
- **Driving Experience:** The car can move outdoors, though it’s still evolving.
- **Practical Learning:** Building this forced me to apply many cybernetics/robotics concepts—power distribution, signal processing, sensor feedback, and more.

> **HoverCar ready to test (weatherproofing not yet implemented):** ![HoverCar ready to test](./Images/HoverCar_test_ready.jpg)

## Electronics & Components

1. **Arduino Mega** – multiple UART pins, central microcontroller.
2. **Hoverboard Motors & Controllers** – repurposed from used hoverboards.
3. **DACs** – smoothing out PWM signals for the pot-based controllers.
4. **ESP32** – Bluetooth module for wireless control.
5. **Batteries** – integrated hoverboard battery packs (be mindful of their voltage ratings).
6. **Miscellaneous** – BTS7960 drivers (used earlier), power cables, sensors, and more.

## Software & Control

- **Language/IDE:** Mostly C/C++ in the Arduino IDE.
- **Wireless Control:** Python + `pygame` for controller inputs, Bluetooth connectivity via ESP32.
- **Firmware:** Custom code for the flashed hoverboard controllers.
- **Motor Control Logic:** PWM signals, digital-to-analog conversion, plus sensor feedback (planned for future expansions).

## Future Plans

- **Refine Code:** Clean up the repository, optimize signal handling, and reduce wiring complexity.
- **Better Drive Experience:** Improve speed control, implement smoother acceleration, and refine steering.
- **Add Sensors:** Incorporate ultrasound, LiDAR, or camera modules for autonomous features.
- **Robot Arm:** Potentially build and mount a robotic manipulator on top for actual tasks.

## Acknowledgements

- Thanks to open-source communities whose hoverboard firmware solutions I relied on. Particularly:
  - https://github.com/rodneybakiskan/ps5-esp32
  - https://github.com/flo199213/Hoverboard-Firmware-Hack-Gen2
  - https://github.com/RoboDurden/Hoverboard-Firmware-Hack-Gen2.x-GD32/tree/main

================
File: HoverCar\HoverCar.ino
================
/***************************************************
  HoverCar.ino - With Smooth Acceleration and Combined Command Support
  
  Features:
  - Gradual acceleration/deceleration for smoother control
  - Support for both traditional and combined command formats
  - Front wheel calibration
  - Watchdog safety timer
****************************************************/

#include <Wire.h>                   // For I2C
#include <Adafruit_MCP4725.h>       // For the DAC
#include "util.h"
#include "hoverserial.h"            // Provided with the hoverboard firmware library

// ========== SETTINGS ==========

// UART BAUD for the flashed hoverboard controllers
#define BAUDRATE       19200

// For clarity, define which hardware serial each side uses
#define SerialLeft     Serial2  // pins 16=TX2->RX,17=RX2->TX
#define SerialRight    Serial3  // pins 14=TX3->RX,15=TX

// Create two DAC objects
Adafruit_MCP4725 dacLeft;
Adafruit_MCP4725 dacRight;

// The addresses for your two MCP4725 boards
#define DACLEFT_ADDR   0x60
#define DACRIGHT_ADDR  0x61

// ---------- SPEED VARIABLES ----------
// Target speeds (where we want to go)
int targetLeftSpeed = 0;   // range: -1000..+1000
int targetRightSpeed = 0;  // range: -1000..+1000

// Current speeds (where we are now)
int currentLeftSpeed = 0;  // range: -1000..+1000
int currentRightSpeed = 0; // range: -1000..+1000

// ---------- ACCELERATION SETTINGS ----------
// These determine how quickly speed changes occur
// Lower values = smoother acceleration but less responsive
// Higher values = quicker response but more jerky
#define ACCEL_RATE 15      // Speed units per update (for accelerating)
#define DECEL_RATE 30      // Speed units per update (for decelerating - usually higher for safety)
#define SPEED_UPDATE_MS 20 // How often to update speeds (milliseconds)

// Command watchdog timer - for safety
#define COMMAND_TIMEOUT_MS 1000  // 1 second timeout
unsigned long lastCommandTime = 0;
unsigned long lastSpeedUpdate = 0;

// Front wheel calibration factor
#define FRONT_WHEEL_CALIBRATION 1.0

// Not strictly needed, but included for completeness
SerialHover2Server oHoverFeedback;

// ===================================================
void setup() {
  // Start USB serial (to communicate with the PC/Python)
  Serial.begin(115200);
  delay(200);
  Serial.println("HoverCar - With Smooth Acceleration - Starting...");

  // Setup Serial1 for ESP32 communication
  Serial1.begin(115200);
  Serial.println("Serial1 started for ESP32 communication");

  // Clear the serial buffers
  while (Serial.available() > 0) Serial.read();
  while (Serial1.available() > 0) Serial1.read();

  // Start the hoverboard controllers (front wheels)
  SerialLeft.begin(BAUDRATE);   // Left front
  SerialRight.begin(BAUDRATE);  // Right front

  // Init I2C and DACs (rear wheels)
  Wire.begin();

  if (!dacLeft.begin(DACLEFT_ADDR)) {
    Serial.println("MCP4725 (left) not found at 0x60! Check wiring.");
    while (1);
  }
  if (!dacRight.begin(DACRIGHT_ADDR)) {
    Serial.println("MCP4725 (right) not found at 0x61! Check wiring.");
    while (1);
  }
  Serial.println("Both DACs found (rear ESCs).");

  // Initialize DACs to zero to prevent startup motor spin
  dacLeft.setVoltage(0, false);
  dacRight.setVoltage(0, false);
  Serial.println("DACs initialized to zero voltage.");

  pinMode(LED_BUILTIN, OUTPUT);
  
  // Initialize timing variables
  lastCommandTime = millis();
  lastSpeedUpdate = millis();
}

void loop() {
  unsigned long currentTime = millis();
  
  // Blink the built-in LED every 500 ms to show the loop is running
  static unsigned long lastBlink = 0;
  if (currentTime - lastBlink >= 500) {
    lastBlink = currentTime;
    digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));
  }

  // Watchdog timeout - if no commands for a while, stop motors
  if (currentTime - lastCommandTime > COMMAND_TIMEOUT_MS) {
    if (targetLeftSpeed != 0 || targetRightSpeed != 0) {
      Serial.println("WATCHDOG: Command timeout - stopping motors!");
      targetLeftSpeed = 0;
      targetRightSpeed = 0;
    }
  }

  // Process commands from ESP32 (Serial1)
  if (Serial1.available()) {
    String cmd = Serial1.readStringUntil('\n');
    cmd.trim(); // remove trailing whitespace

    // Update the watchdog timer
    lastCommandTime = currentTime;
    
    // Process commands
    if (cmd.equalsIgnoreCase("0") || cmd.equalsIgnoreCase("S=0")) {
      targetLeftSpeed = 0;
      targetRightSpeed = 0;
    }
    else if (cmd.startsWith("L=") || cmd.startsWith("l=")) {
      targetLeftSpeed = constrain(cmd.substring(2).toInt(), -1000, 1000);
    }
    else if (cmd.startsWith("R=") || cmd.startsWith("r=")) {
      targetRightSpeed = constrain(cmd.substring(2).toInt(), -1000, 1000);
    }
    // Combined command format: "LR=left,right"
    else if (cmd.startsWith("LR=") || cmd.startsWith("lr=")) {
      String values = cmd.substring(3); // Skip "LR="
      int commaIndex = values.indexOf(',');
      
      if (commaIndex > 0) {
        String leftStr = values.substring(0, commaIndex);
        String rightStr = values.substring(commaIndex + 1);
        
        targetLeftSpeed = constrain(leftStr.toInt(), -1000, 1000);
        targetRightSpeed = constrain(rightStr.toInt(), -1000, 1000);
      }
    }

    // Debug output (rate-limited to avoid flooding)
    static unsigned long lastDebugPrint = 0;
    if (currentTime - lastDebugPrint >= 500) {
      lastDebugPrint = currentTime;
      Serial.print("ESP32 CMD â†’ Target: L=");
      Serial.print(targetLeftSpeed);
      Serial.print(", R=");
      Serial.println(targetRightSpeed);
    }
  }

  // Process commands from USB Serial (manual control)
  if (Serial.available()) {
    String cmd = Serial.readStringUntil('\n');
    cmd.trim(); // remove trailing whitespace

    // Update the watchdog timer
    lastCommandTime = currentTime;
    
    // Process command
    if (cmd.equalsIgnoreCase("0")) {
      targetLeftSpeed = 0;
      targetRightSpeed = 0;
      Serial.println("Both sides set to 0.");
    }
    else if (cmd.equalsIgnoreCase("S=0")) {
      targetLeftSpeed = 0;
      targetRightSpeed = 0;
      Serial.println("Motors stopped (S=0).");
    }
    else if (cmd.startsWith("L=") || cmd.startsWith("l=")) {
      targetLeftSpeed = constrain(cmd.substring(2).toInt(), -1000, 1000);
      Serial.print("Target left speed set to ");
      Serial.println(targetLeftSpeed);
    }
    else if (cmd.startsWith("R=") || cmd.startsWith("r=")) {
      targetRightSpeed = constrain(cmd.substring(2).toInt(), -1000, 1000);
      Serial.print("Target right speed set to ");
      Serial.println(targetRightSpeed);
    }
    else if (cmd.startsWith("LR=") || cmd.startsWith("lr=")) {
      String values = cmd.substring(3);
      int commaIndex = values.indexOf(',');
      
      if (commaIndex > 0) {
        String leftStr = values.substring(0, commaIndex);
        String rightStr = values.substring(commaIndex + 1);
        
        targetLeftSpeed = constrain(leftStr.toInt(), -1000, 1000);
        targetRightSpeed = constrain(rightStr.toInt(), -1000, 1000);
        
        Serial.print("Target speeds set to L=");
        Serial.print(targetLeftSpeed);
        Serial.print(", R=");
        Serial.println(targetRightSpeed);
      }
    }
    // Special command to adjust acceleration rate
    else if (cmd.startsWith("ACCEL=")) {
      int newRate = constrain(cmd.substring(6).toInt(), 1, 100);
      Serial.print("Setting acceleration rate to ");
      Serial.println(newRate);
      // We'd update a global variable here if we were using one
    }
    else {
      Serial.println("Unrecognized command. Examples:");
      Serial.println("  0      (both sides to 0)");
      Serial.println("  S=0    (explicit stop)");
      Serial.println("  L=300  (left speed=300)");
      Serial.println("  R=-150 (right speed=-150)");
      Serial.println("  LR=300,-150 (combined command)");
      Serial.println("  ACCEL=10 (set acceleration rate)");
    }
  }

  // ===== SMOOTH ACCELERATION/DECELERATION =====
  // Update speeds at controlled intervals
  if (currentTime - lastSpeedUpdate >= SPEED_UPDATE_MS) {
    lastSpeedUpdate = currentTime;
    
    // Gradually approach target left speed
    if (currentLeftSpeed < targetLeftSpeed) {
      // Accelerating - use ACCEL_RATE
      currentLeftSpeed = min(currentLeftSpeed + ACCEL_RATE, targetLeftSpeed);
    } else if (currentLeftSpeed > targetLeftSpeed) {
      // Decelerating - use DECEL_RATE (usually faster for safety)
      currentLeftSpeed = max(currentLeftSpeed - DECEL_RATE, targetLeftSpeed);
    }
    
    // Gradually approach target right speed
    if (currentRightSpeed < targetRightSpeed) {
      currentRightSpeed = min(currentRightSpeed + ACCEL_RATE, targetRightSpeed);
    } else if (currentRightSpeed > targetRightSpeed) {
      currentRightSpeed = max(currentRightSpeed - DECEL_RATE, targetRightSpeed);
    }
    
    // Debug output (rate-limited)
    static unsigned long lastSpeedPrint = 0;
    if (currentTime - lastSpeedPrint >= 1000) { // Once per second
      lastSpeedPrint = currentTime;
      Serial.print("Current: L=");
      Serial.print(currentLeftSpeed);
      Serial.print(", R=");
      Serial.print(currentRightSpeed);
      Serial.print(" | Target: L=");
      Serial.print(targetLeftSpeed);
      Serial.print(", R=");
      Serial.println(targetRightSpeed);
    }
  }

  // Apply front wheel calibration if needed
  int adjustedLeftSpeed = -currentLeftSpeed;   // Note the negation for direction
  int adjustedRightSpeed = currentRightSpeed;
  
  if (FRONT_WHEEL_CALIBRATION < 1.0) {
    // Slow down the right wheel
    adjustedRightSpeed = (int)(adjustedRightSpeed * FRONT_WHEEL_CALIBRATION);
  } else if (FRONT_WHEEL_CALIBRATION > 1.0) {
    // Slow down the left wheel
    adjustedLeftSpeed = (int)(adjustedLeftSpeed / FRONT_WHEEL_CALIBRATION);
  }

  // Send speed commands to FRONT hoverboard controllers (UART)
  HoverSend(SerialLeft,  0, adjustedLeftSpeed,  32);
  HoverSend(SerialRight, 0, adjustedRightSpeed, 32);

  // Drive REAR ESCs with DAC (forward-only, so clamp negatives to 0)
  setLeftESC(currentLeftSpeed);
  setRightESC(currentRightSpeed);

  // Short delay to prevent CPU hogging
  delay(5);
}

// ========== HELPER FUNCTIONS ==========

/**
 * Sets the voltage for the LEFT ESC using the left DAC
 * range -1000..+1000, but clamp negative to 0 for forward-only
 */
void setLeftESC(int speedValue) {
  if (speedValue < 0)  speedValue = 0;     // clamp negative to 0
  if (speedValue > 1000) speedValue = 1000;

  // Map 0..1000 to 0..4095 (12-bit DAC)
  uint16_t dacVal = map(speedValue, 0, 1000, 0, 4095);
  dacLeft.setVoltage(dacVal, false);
}

/**
 * Sets the voltage for the RIGHT ESC using the right DAC
 * range -1000..+1000, but clamp negative to 0 for forward-only
 */
void setRightESC(int speedValue) {
  if (speedValue < 0)  speedValue = 0;
  if (speedValue > 1000) speedValue = 1000;

  // Map 0..1000 to 0..4095
  uint16_t dacVal = map(speedValue, 0, 1000, 0, 4095);
  dacRight.setVoltage(dacVal, false);
}

================
File: HoverCar\hoverserial.h
================
// hoverserial.h v20231224
/*
// Variables todo
uint8_t upperLEDMaster = 0;
uint8_t lowerLEDMaster = 0;
uint8_t mosfetOutMaster = 0;
uint8_t upperLEDSlave = 0;
uint8_t lowerLEDSlave = 0;
uint8_t mosfetOutSlave = 0;
uint8_t beepsBackwards = 0;
uint8_t activateWeakening = 0;
*/

template <typename O,typename I> void HoverSetupEsp32(O& oSerial, I iBaud, I gpio_RX, I gpio_TX)
{
  // Starts the serial connection using the baud, protocol, GPIO RX, GPIO TX.
  // These are the GPIO numbers; not necessarily the pin number printed on the PCB.
  oSerial.begin(iBaud, SERIAL_8N1, gpio_RX, gpio_TX);
}
template <typename O,typename I> void HoverSetupArduino(O& oSerial, I iBaud)
{
  oSerial.begin(iBaud);
}

uint16_t CalcCRC(uint8_t *ptr, int count)
{
  uint16_t  crc;
  uint8_t i;
  crc = 0;
  while (--count >= 0)
  {
    crc = crc ^ (uint16_t) *ptr++ << 8;
    i = 8;
    do
    {
      if (crc & 0x8000)
      {
        crc = crc << 1 ^ 0x1021;
      }
      else
      {
        crc = crc << 1;
      }
    } while(--i);
  }
  return (crc);
}


#define START_FRAME         0xABCD       // [-] Start frme definition for reliable serial communication

#ifdef REMOTE_UARTBUS
  typedef struct __attribute__((packed, aligned(1))) {
     uint16_t cStart = START_FRAME;    //  = '/';
     uint8_t iSlave;    //  the slave id this message is sent from
     int16_t iSpeed;   // 100* km/h
     uint16_t iVolt;    // 100* V
     int16_t iAmp;   // 100* A
     int32_t iOdom;    // hall steps
     uint16_t checksum;
  } SerialHover2Server;
  
  //typedef struct{   // new version
  //   uint16_t cStart = START_FRAME;   // new version
  typedef struct __attribute__((packed, aligned(1))) {
     uint8_t  cStart = '/';
     uint8_t  iDataType = 0;    //  unique id for this data struct
     uint8_t  iSlave;       //  contains the slave id this message is intended for
     int16_t  iSpeed = 0;
     uint8_t  wState = 0;   // 1=ledGreen, 2=ledOrange, 4=ledRed, 8=ledUp, 16=ledDown   , 32=Battery3Led, 64=Disable, 128=ShutOff
     uint16_t checksum;
  } SerialServer2Hover;
  typedef struct __attribute__((packed, aligned(1))) {
     uint8_t  cStart = '/';
     uint8_t  iDataType = 1;    //  unique id for this data struct
     uint8_t  iSlave;       //  contains the slave id this message is intended for
     int16_t  iSpeed = 0;
     int16_t  iSteer = 0;
     uint8_t  wState = 0;   // 1=ledGreen, 2=ledOrange, 4=ledRed, 8=ledUp, 16=ledDown   , 32=Battery3Led, 64=Disable, 128=ShutOff
     uint8_t  wStateSlave = 0;   // 1=ledGreen, 2=ledOrange, 4=ledRed, 8=ledUp, 16=ledDown   , 32=Battery3Led, 64=Disable, 128=ShutOff
     uint16_t checksum;
  } SerialServer2HoverMaster;
  
  typedef struct __attribute__((packed, aligned(1))) { 
     uint8_t cStart     = '/';      //  unique id for this data struct
     uint8_t  iDataType = 2;  //  unique id for this data struct
     uint8_t  iSlave;     //  contains the slave id this message is intended for
     float  fBattFull     = 42.0;    // 10s LiIon = 42.0;
     float  fBattEmpty    = 27.0;    // 10s LiIon = 27.0;
     uint8_t  iDriveMode  = 2;      //  MM32: 0=COM_VOLT, 1=COM_SPEED, 2=SINE_VOLT, 3=SINE_SPEED
     int8_t   iSlaveNew   = -1;      //  if >= 0 contains the new slave id saved to eeprom
     uint16_t checksum;
  } SerialServer2HoverConfigMM32;

  SerialServer2HoverConfigMM32 oHoverConfig;

  template <typename O,typename D> void HoverSendData(O& oSerial, D& oData)
  {
    oData.checksum = CalcCRC((uint8_t*)&oData, sizeof(oData)-2); // first bytes except crc
    oSerial.write((uint8_t*) &oData, sizeof(oData)); 
    //DEBUGN(oData.iSlave, sizeof(oData)); 
  }

template <typename O,typename I> void HoverSend(O& oSerial, I iSteer, I iSpeed,uint8_t wStateMaster=32, uint8_t wStateSlave=0)
{
Serial.println("Sending command - Steer: " + String(iSteer) + ", Speed: " + String(iSpeed)); // Debug print
//DEBUGT("iSteer",iSteer);DEBUGN("iSpeed",iSpeed);
SerialServer2Hover oData;
oData.iSpeed = (int16_t)iSpeed;
oData.iSteer = (int16_t)iSteer;
oData.wStateMaster = wStateMaster;
oData.wStateSlave = wStateSlave;
oData.checksum = CalcCRC((uint8_t*)&oData, sizeof(SerialServer2Hover)-2); // first bytes except crc
oSerial.write((uint8_t*) &oData, sizeof(SerialServer2Hover));
//DebugOut((uint8_t*) &oData, sizeof(oData));
}
  
  void HoverLog(SerialHover2Server& oData)
  {
    DEBUGT("iSlave",oData.iSlave);
    DEBUGT("iOdom",oData.iOdom);
    DEBUGT("\tiSpeed",(float)oData.iSpeed/100.0);
    DEBUGT("\tiAmp",(float)oData.iAmp/100.0);
    DEBUGN("\tiVolt",(float)oData.iVolt/100.0);
  }
  void HoverLogConfigMM32(SerialServer2HoverConfigMM32& oConfig)
  {
    DEBUGT("config for iSlave",oConfig.iSlave);
    DEBUGT("fBattFull",oConfig.fBattFull);
    DEBUGT("fBattEmpty",oConfig.fBattEmpty);
    DEBUGT("iDriveMode",oConfig.iDriveMode);
    DEBUGN("iSlaveNew",oConfig.iSlaveNew);
  }

#else

  typedef struct __attribute__((packed, aligned(1))) {
     uint16_t cStart = START_FRAME;    //  = '/';
     int16_t iSpeedL;   // 100* km/h
     int16_t iSpeedR;   // 100* km/h
     uint16_t iVolt;    // 100* V
     int16_t iAmpL;   // 100* A
     int16_t iAmpR;   // 100* A
     int32_t iOdomL;    // hall steps
     int32_t iOdomR;    // hall steps
     uint16_t checksum;
  } SerialHover2Server;
  
  //typedef struct{   // new version
  //   uint16_t cStart = START_FRAME;   // new version
  typedef struct __attribute__((packed, aligned(1))) {  // old version
     uint8_t cStart = '/';                              // old version
     int16_t  iSpeed = 0;
     int16_t  iSteer = 0;
     uint8_t  wStateMaster = 0;   // 1=ledGreen, 2=ledOrange, 4=ledRed, 8=ledUp, 16=ledDown   , 32=Battery3Led, 64=Disable, 128=ShutOff
     uint8_t  wStateSlave = 0;   // 1=ledGreen, 2=ledOrange, 4=ledRed, 8=ledUp, 16=ledDown   , 32=Battery3Led, 64=Disable, 128=ShutOff
     uint16_t checksum;
  } SerialServer2Hover;

template <typename O,typename I> void HoverSend(O& oSerial, I iSteer, I iSpeed,uint8_t wStateMaster=32, uint8_t wStateSlave=0)
{
Serial.println("Sending command - Steer: " + String(iSteer) + ", Speed: " + String(iSpeed)); // Debug print
//DEBUGT("iSteer",iSteer);DEBUGN("iSpeed",iSpeed);
SerialServer2Hover oData;
oData.iSpeed = (int16_t)iSpeed;
oData.iSteer = (int16_t)iSteer;
oData.wStateMaster = wStateMaster;
oData.wStateSlave = wStateSlave;
oData.checksum = CalcCRC((uint8_t*)&oData, sizeof(SerialServer2Hover)-2); // first bytes except crc
oSerial.write((uint8_t*) &oData, sizeof(SerialServer2Hover));
//DebugOut((uint8_t*) &oData, sizeof(oData));
}
  
  template <typename O,typename I> void HoverSendLR(O& oSerial, I iSpeedLeft, I iSpeedRight) // -1000 .. +1000
  {
    // speed coeff in config.h must be 1.0 : (DEFAULT_)SPEED_COEFFICIENT   16384
    // steer coeff in config.h must be 0.5 : (DEFAULT_)STEER_COEFFICIENT   8192 
    HoverSend(oSerial,iSpeedRight - iSpeedLeft,(iSpeedLeft + iSpeedRight)/2);
  }
  
  void HoverLog(SerialHover2Server& oData)
  {
    DEBUGT("iOdomL",oData.iOdomL);
    DEBUGT("\tiOdomR",oData.iOdomR);
    DEBUGT("\tiSpeedL",(float)oData.iSpeedL/100.0);
    DEBUGT(" iSpeedR",(float)oData.iSpeedR/100.0);
    DEBUGT("\tiAmpL",(float)oData.iAmpL/100.0);
    DEBUGT(" iAmpR",(float)oData.iAmpR/100.0);
    DEBUGN("\tiVolt",(float)oData.iVolt/100.0);
  }

  void HoverDebug(SerialHover2Server& oData)
  {
    DEBUGTX("0",oData.iVolt);
    DEBUGTB("1",oData.iAmpL);
    DEBUGTB("2",oData.iAmpR);
    DEBUGTB("3",oData.iSpeedL);
    DEBUGN("4",oData.iSpeedR);
  }

  void HoverDebug2(SerialHover2Server& oData)
  {
    DEBUGT("0",oData.iVolt);
    DEBUGT("1",oData.iAmpL);
    DEBUGT("2",oData.iAmpR);
    DEBUGT("3",oData.iSpeedL);
    DEBUGT("4",oData.iSpeedR);
    DEBUGT("5",oData.iOdomL);
    DEBUGN("6",oData.iOdomR);
  }

#endif






void DebugOut(uint8_t aBuffer[], uint8_t iSize)
{
  for (int i=0; i<iSize; i++)
  {
    uint8_t c = aBuffer[i];
    Serial.print((c < 16) ? " 0" : " ");Serial.print(c,HEX); 
  }
  Serial.println();
}


  

#ifdef DEBUG_RX
  unsigned long iLastRx = 0;
#endif

//boolean Receive(Serial& oSerial, SerialFeedback& Feedback)
template <typename O,typename OF> boolean Receive(O& oSerial, OF& Feedback)
{
  int iTooMuch = oSerial.available() - sizeof(SerialHover2Server) + 1;
  int8_t bFirst = 1;
  while (iTooMuch >= bFirst )
  {
    byte c = oSerial.read();  // Read the incoming byte
    iTooMuch--;

    #ifdef DEBUG_RX
      //if (millis() > iLastRx + 50)  Serial.println();
      Serial.print((c < 16) ? " 0" : " ");Serial.print(c,HEX); 
      iLastRx = millis();
    #endif
    
    if (bFirst) // test first START byte
    {
      if (c == (byte)START_FRAME) //if (c == 0xCD)
      {
        bFirst = 0;
      }
    }
    else  // test second START byte
    {
      if (c == START_FRAME >>8 ) //if (c == 0xAB)
      {
        //DEBUGT(" avail",oSerial.available())
        SerialHover2Server tmpFeedback;
        byte* p = (byte *)&tmpFeedback+2; // start word already read
        for (int i = sizeof(SerialHover2Server); i>2; i--)  
          *p++    = oSerial.read();

        //while(oSerial.available()) oSerial.read();
        #ifdef DEBUG_RX
          //Serial.print(" -> ");
          //HoverLog(tmpFeedback);
        #endif

        uint16_t checksum = CalcCRC((byte *)&tmpFeedback, sizeof(SerialHover2Server)-2);
        if (checksum == tmpFeedback.checksum)
        {
            memcpy(&Feedback, &tmpFeedback, sizeof(SerialHover2Server));
            #ifdef DEBUG_RX
              Serial.println(" :-)");
            #endif
            return true;
        }
        #ifdef DEBUG_RX
          Serial.print(tmpFeedback.checksum, HEX);
          Serial.print(" != ");
          Serial.print(checksum,HEX);
          Serial.println(" :-(");
        #endif
        return false;       
      }
      if (c != (byte)START_FRAME) //if (c != 0xCD)
        bFirst = 1;
    }
  }
  return false;
}

================
File: HoverCar\util.h
================
#ifndef UTIL_H
#define UTIL_H

String ShiftValue(String &sLine, char* c)
{
  //Serial.println("ShiftValue:'"+sLine+"'");
  int i = sLine.indexOf(c);
  String s = sLine.substring(0,i);
  sLine.remove(0,i+1);
  return s;
}

boolean isUInt(String str)
{
  for(byte i=0; i<str.length(); i++)
    if (!isDigit(str.charAt(i)) )
      return false;

  return true;
}

#define ABS(a) (((a) < 0.0) ? -(a) : (a))
#define CLAMP(x, low, high) (((x) > (high)) ? (high) : (((x) < (low)) ? (low) : (x)))
#define MAP(x, xMin, xMax, yMin, yMax) ((x - xMin) * (yMax - yMin) / (xMax - xMin) + yMin)


#ifdef _DEBUG
  #define DEBUG(txt, val) {Serial.print(F(txt)); Serial.print(F(": ")); Serial.print(val);}
  #define DEBUGT(txt, val) {Serial.print(F(txt)); Serial.print(F(": ")); Serial.print(val); Serial.print(F("\t"));}
  #define DEBUGTX(txt, val) {Serial.print(F(txt)); Serial.print(F(": ")); Serial.print(val,HEX); Serial.print(F("\t"));}
  #define DEBUGTB(txt, val) {Serial.print(F(txt)); Serial.print(F(": ")); Serial.print(val,BIN); Serial.print(F("\t"));}
  #define DEBUGN(txt, val) {Serial.print(F(txt)); Serial.print(F(": ")); Serial.println(val);}
#else
  #define DEBUG(txt, val)
  #define DEBUGT(txt, val)
  #define DEBUGTX(txt, val)
  #define DEBUGTB(txt, val)
  #define DEBUGN(txt, val)
#endif

#endif // UTIL_H

================
File: HoverCarControllerESP32\controller.py
================
#!/usr/bin/env python3

import pygame
import serial
import time
import sys

def main():
    # === 1) Init Pygame ===
    pygame.init()
    pygame.joystick.init()
    joy_count = pygame.joystick.get_count()
    print(f"Pygame sees {joy_count} joysticks.", flush=True)
    joystick = None
    if joy_count > 0:
        joystick = pygame.joystick.Joystick(0)
        joystick.init()
        print(f"Using joystick: {joystick.get_name()}", flush=True)
    else:
        print("No joystick connected. Exiting.")
        sys.exit(1)

    # === 2) Init Serial ===
    try:
        ser = serial.Serial('COM3', 115200, timeout=0.1)
    except Exception as e:
        print(f"Could not open serial port: {e}")
        sys.exit(1)

    time.sleep(2)  # one-time wait to let Arduino reset
    print("Starting R2/L2 + Steering control loop...", flush=True)

    # -- Axis indices (likely for PS4/PS5 on many systems) --
    # Double-check with a quick axis print if needed
    AXIS_L2 = 4      # L2 trigger
    AXIS_R2 = 5      # R2 trigger
    AXIS_STEER = 0   # Left stick X for steering

    def convertTrigger(val):
        """
        Convert trigger from [-1..+1] => [0..1].
          - -1 means not pressed
          - +1 means fully pressed
        """
        return (val + 1.0) / 2.0

    def deadzone(value, threshold=0.05):
        return 0.0 if abs(value) < threshold else value

    loop_count = 0
    while True:
        pygame.event.pump()
        loop_count += 1

        # If joystick is present, read the triggers + steering axis
        raw_l2 = joystick.get_axis(AXIS_L2)   # typically -1..+1
        raw_r2 = joystick.get_axis(AXIS_R2)
        raw_steer = joystick.get_axis(AXIS_STEER)  # left stick X, typically -1..+1

        # Convert L2/R2 to 0..1 range
        l2_val = convertTrigger(raw_l2)  # 0=unpressed, 1=fully pressed
        r2_val = convertTrigger(raw_r2)

        # Apply a small deadzone to steering
        steer = deadzone(raw_steer, 0.05)

        # Scale triggers to 0..1000
        throttle_speed = int(r2_val * 1000)  # 0..1000
        reverse_speed  = int(l2_val * 1000)  # 0..1000
        steering_val   = int(steer * 1000)   # -1000..+1000

        # Net speed: R2 for forward, L2 for reverse => net_speed in [-1000..+1000]
        net_speed = throttle_speed - reverse_speed

        # Arcade mixing for left & right motors:
        #   left_motor  = net_speed + steering
        #   right_motor = net_speed - steering
        left_val  = net_speed + steering_val
        right_val = net_speed - steering_val

        # Clamp to -1000..+1000
        left_val  = max(-1000, min(1000, left_val))
        right_val = max(-1000, min(1000, right_val))

        # Print some debug info
        print(
            f"Loop={loop_count}, "
            f"L2={l2_val:.2f}, R2={r2_val:.2f}, Steer={steer:.2f}, "
            f"LeftVal={left_val}, RightVal={right_val}",
            flush=True
        )


        # Send commands to Arduino
        cmd_left = f"L={left_val}\n"
        cmd_right = f"R={right_val}\n"
        ser.write(cmd_left.encode('utf-8'))
        ser.write(cmd_right.encode('utf-8'))

        # Read any Arduino response
        if ser.in_waiting > 0:
            response = ser.read(ser.in_waiting).decode('utf-8', errors='ignore')
            print(f"Arduino replied: {response}", flush=True)

        # ~40 updates/second
        time.sleep(0.1)

if __name__ == "__main__":
    main()

================
File: HoverCarControllerESP32\HoverCarControllerESP32.ino
================
/*********************************************************************************
  ESP32 Sketch using Bluepad32 to read PS5 controller, then send commands
  to Arduino Mega for your hoverboard car.

  Optimized with:
  - Combined commands to reduce serial overhead
  - Improved timing and reduced unnecessary delays 
  - Only sends commands when values change or after time interval
  - Enhanced deadzones to prevent drift
**********************************************************************************/

#include <Arduino.h>
#include <Bluepad32.h>
#include <HardwareSerial.h>

// CREATE A HARDWARE SERIAL INTERFACE FOR MEGA
HardwareSerial SerialMega(2); // "2" = UART2 instance

// Bluepad32 can connect up to 4 controllers.
ControllerPtr myControllers[BP32_MAX_GAMEPADS];

// Track the controller connection
bool wasConnected = false;

// Current and previous values for change detection
int prevLeftVal = 0;
int prevRightVal = 0;
unsigned long lastCommandTime = 0;

// Deadzone settings
#define THROTTLE_DEADZONE 70    // Deadzone for throttle/brake (0-1023)
#define STEERING_DEADZONE 70    // Deadzone for steering axis (-512 to 511)

// Timing settings
#define MIN_COMMAND_INTERVAL_MS 40  // Only send commands at most every X ms
#define FORCE_COMMAND_INTERVAL_MS 200  // Force sending commands every X ms even if values haven't changed

// Called when a new controller connects
void onConnectedController(ControllerPtr ctl) {
  Serial.println("Controller connected!");
  for (int i = 0; i < BP32_MAX_GAMEPADS; i++) {
    if (myControllers[i] == nullptr) {
      myControllers[i] = ctl;
      Serial.printf("Assigned to slot %d\n", i);
      break;
    }
  }
}

// Called when a controller disconnects
void onDisconnectedController(ControllerPtr ctl) {
  Serial.println("Controller disconnected!");
  for (int i = 0; i < BP32_MAX_GAMEPADS; i++) {
    if (myControllers[i] == ctl) {
      myControllers[i] = nullptr;
      
      // Send emergency stop when controller disconnects
      sendEmergencyStop();
      break;
    }
  }
}

// Send emergency stop commands - combined command format
void sendEmergencyStop() {
  Serial.println("Sending emergency stop");
  
  // Send once with combined format
  SerialMega.print("LR=0,0\n");
  
  // Send traditional format as backup
  SerialMega.print("L=0\n");
  SerialMega.print("R=0\n");
  SerialMega.print("S=0\n");
}

// Simple helper to clamp values
int clampValue(int v, int minV, int maxV) {
  if (v > maxV) return maxV;
  if (v < minV) return minV;
  return v;
}

// Apply deadzone to any value
int applyDeadzone(int value, int deadzone) {
  if (abs(value) < deadzone) {
    return 0;
  }
  return value;
}

// Send motor commands with rate limiting
void sendMotorCommands(int leftVal, int rightVal) {
  unsigned long currentTime = millis();
  
  // Only send if values changed or enough time has passed
  bool valuesChanged = (leftVal != prevLeftVal || rightVal != prevRightVal);
  bool intervalElapsed = (currentTime - lastCommandTime) >= MIN_COMMAND_INTERVAL_MS;
  bool forceUpdate = (currentTime - lastCommandTime) >= FORCE_COMMAND_INTERVAL_MS;
  
  if ((valuesChanged && intervalElapsed) || forceUpdate) {
    // Combined command format - more efficient
    char cmdCombined[32];
    sprintf(cmdCombined, "LR=%d,%d\n", leftVal, rightVal);
    SerialMega.print(cmdCombined);
    
    // Update tracking variables
    prevLeftVal = leftVal;
    prevRightVal = rightVal;
    lastCommandTime = currentTime;
    
    // Debug output
    Serial.printf("Sent: %s", cmdCombined);
  }
}

void setup() {
  Serial.begin(115200);
  delay(100);
  Serial.println("ESP32 PS5 Controller - Optimized Version");

  // Initialize hardware serial to Arduino Mega
  // Increase baud rate for better communication
  SerialMega.begin(115200, SERIAL_8N1, 16, 17);
  delay(50);

  // Setup Bluepad32
  BP32.setup(&onConnectedController, &onDisconnectedController);
  BP32.enableVirtualDevice(false);

  Serial.println("Setup done. Waiting for controllers...");
  
  // Send initial stop command
  sendEmergencyStop();
  
  // Initialize timing variables
  lastCommandTime = millis();
}

void loop() {
  // Fetch controller updates - no delay if no update
  BP32.update();
  
  // Check if any controller is connected
  bool isConnected = false;
  for (int i = 0; i < BP32_MAX_GAMEPADS; i++) {
    if (myControllers[i] != nullptr && myControllers[i]->isConnected()) {
      isConnected = true;
      break;
    }
  }
  
  // Detect controller disconnect
  if (wasConnected && !isConnected) {
    Serial.println("Controller connection lost!");
    sendEmergencyStop();
  }
  wasConnected = isConnected;
  
  // Process each connected controller
  for (int i = 0; i < BP32_MAX_GAMEPADS; i++) {
    ControllerPtr ctl = myControllers[i];
    if (ctl && ctl->isConnected()) {
      // Always read the latest values whether hasData() is true or not
      // This ensures we get the most up-to-date controller state
      
      // Read throttle (R2) and brake (L2)
      int throttleRaw = ctl->throttle(); // R2
      int brakeRaw = ctl->brake();      // L2

      // Read left stick X for steering
      int16_t axisX = ctl->axisX();
      
      // Apply deadzones
      throttleRaw = applyDeadzone(throttleRaw, THROTTLE_DEADZONE);
      brakeRaw = applyDeadzone(brakeRaw, THROTTLE_DEADZONE);
      axisX = applyDeadzone(axisX, STEERING_DEADZONE);

      // Convert to motor speed ranges
      int netSpeed = map(throttleRaw - brakeRaw, -1023, 1023, -1000, 1000);
      int steeringVal = map(axisX, -512, 511, -1000, 1000);

      // Arcade mixing
      int leftVal = netSpeed + steeringVal;
      int rightVal = netSpeed - steeringVal;

      // Clamp speeds
      leftVal = clampValue(leftVal, -1000, 1000);
      rightVal = clampValue(rightVal, -1000, 1000);

      // Send commands (with rate limiting)
      sendMotorCommands(leftVal, rightVal);
    }
  }
  
  // Very short delay for task scheduling
  // This is important for ESP32 background tasks but won't cause stuttering
  delay(5);
}

================
File: ps5-esp32-main\component.mk
================
#
# Component Makefile
#

COMPONENT_SRCDIRS := src
COMPONENT_ADD_INCLUDEDIRS := src/include

COMPONENT_OBJS := src/ps5.o src/ps5_spp.o src/ps5_parser.o src/ps5_l2cap.o

COMPONENT_EXTRA_INCLUDES +=     $(IDF_PATH)/components/bt/common/include/                     \
                                $(IDF_PATH)/components/bt/host/bluedroid/common/include/      \
                                $(IDF_PATH)/components/bt/host/bluedroid/stack/include        \
                                $(IDF_PATH)/components/bt/host/bluedroid/stack/l2cap/include    \
                                $(IDF_PATH)/components/bt/host/bluedroid/osi/include

# Legacy bluedroid location include paths
# i.e. ESP-IDF prior to revision 21165edf41813482bd1d0a8183969854d1011f24
COMPONENT_EXTRA_INCLUDES +=     $(IDF_PATH)/components/bt/bluedroid/common/include/           \
                                $(IDF_PATH)/components/bt/bluedroid/stack/include             \
                                $(IDF_PATH)/components/bt/bluedroid/stack/l2cap/include         \
								$(IDF_PATH)/components/bt/bluedroid/osi/include

COMPONENT_DEPENDS := bt

================
File: ps5-esp32-main\Kconfig
================
menu ps5

    choice IDF_COMPATIBILITY
        prompt "Framework compatibility"
        default IDF_COMPATIBILITY_STABLE
        help
            The esp32-ps5 project uses internal APIs that can change without notice.

            This option allows you to use older ESP-IDF versions, in case you get compilation
            errors.

            If you are unsure which master branch revision you should take, figure out what the
            commit date is of your ESP-IDF version (by running `git show`), and look at the help
            text of each revision listed here to know their revision date.

        config IDF_COMPATIBILITY_STABLE
            bool "Latest stable release"
        config IDF_COMPATIBILITY_MASTER
            bool "Latest master revision"

        config IDF_COMPATIBILITY_MASTER_21165ED
            bool "Master branch revision 21165ed and later"
            help
                Revision date: 30-June-2019
                Revision message: Bluetooth component refactoring
        config IDF_COMPATIBILITY_MASTER_D9CE0BB
            bool "Master branch revision d9ce0bb and later"
            help
                Revision date: 13-March-2019
                Revision message: Modify esp_bt_gap_set_scan_mode() to be able to set connection modes
                                    as well as discoverable modes
        config IDF_COMPATIBILITY_MASTER_21AF1D7
            bool "Master branch revision 21af1d7 and later"
            help
                Revision date: 10-July-2018
                Revision message: Add Secure Simple Pairing
    endchoice

    config IDF_COMPATIBILITY
        int
        default 1 if IDF_COMPATIBILITY_STABLE
        default 3 if IDF_COMPATIBILITY_MASTER

        default 3 if IDF_COMPATIBILITY_MASTER_21165ED
        default 2 if IDF_COMPATIBILITY_MASTER_D9CE0BB
        default 1 if IDF_COMPATIBILITY_MASTER_21AF1D7

endmenu

================
File: ps5-esp32-main\keywords.txt
================
ps5Controller KEYWORD1
ps5 KEYWORD1

begin KEYWORD2
end KEYWORD2
isConnected KEYWORD2
setLed KEYWORD2
setRumble KEYWORD2
setFlashRate KEYWORD2
sendToController KEYWORD2
LatestPacket KEYWORD2
attach KEYWORD2
attachOnConnect KEYWORD2
attachOnDisconnect KEYWORD2
Right KEYWORD2
Down KEYWORD2
Up KEYWORD2
Left KEYWORD2
Square KEYWORD2
Cross KEYWORD2
Circle KEYWORD2
Triangle KEYWORD2
UpRight KEYWORD2
DownRight KEYWORD2
UpLeft KEYWORD2
DownLeft KEYWORD2
L1 KEYWORD2
R1 KEYWORD2
L2 KEYWORD2
R2 KEYWORD2
Share KEYWORD2
Options KEYWORD2
L3 KEYWORD2
R3 KEYWORD2
PSButton KEYWORD2
Touchpad KEYWORD2
L2Value KEYWORD2
R2Value KEYWORD2
LStickX KEYWORD2
LStickY KEYWORD2
RStickX KEYWORD2
RStickY KEYWORD2

event	KEYWORD3

================
File: ps5-esp32-main\library.properties
================
name=ps5Controller
version=2.1
author=Albert III
maintainer=Albert III
sentence=Control your ESP32 projects with a ps5 controller!
paragraph=Emulate a ps5 console tricking the ps5 controller into connecting with the ESP32.
category=Communication
url=https://github.com/aed3/ps5-esp32
architectures=esp32

================
File: ps5-esp32-main\README.md
================
# ps5-esp32
Use a ps5 controller with an ESP32.

This is heavily based on the work of Jeffery Pernis to connect a PS3 controller to an ESP32, and the PS4-esp32 library. 

PS3 controller: https://github.com/jvpernis/esp32-ps3

PS4 controller: https://github.com/aed3/PS4-esp32

[Here's a video](https://youtu.be/BmlKBs27pgE) about how the ps4 library was made.

This repo can be downloaded as a zip file and imported into the Arduino IDE as a library.

## Installation
The instructions on how to do this are base off what can be found [here](https://github.com/jvpernis/esp32-ps3/issues/3#issuecomment-517141523)
1. You can add the ESP32 boards to your Arduino IDE by adding them to the Boards Manager:
    1. Open `File -> Preferences`
    1. Paste the following URL in the `Additional Boards Manager URLs` field:
    `https://dl.espressif.com/dl/package_esp32_index.json`
    1. Open the Boards Manager with `Tools -> Board: "xxx" -> Boards Manager`
    1. Look for `esp32` (probably the last one in the list), and click `install`
    1. Select the ESP32 board you have with `Tools -> Board: "xxx"` under the section `ESP32 Arduino`
1. To install this library into your Arduino IDE:
    1. Click on the "Code" button in the top right of this page
    1. Select "Download Zip" (It's always a good idea to look through the code on this page first to make sure you know what you're downloading)
    1. In the Arduino IDE, navigate to `Sketch -> Include Library -> Add .ZIP Library`, then select the file you just downloaded


## Pairing the ps5 Controller:
When a ps5 controller is 'paired' to a ps5 console, it just means that it has stored the console's Bluetooth MAC address, which is the only device the controller will connect to. Usually, this pairing happens when you connect the controller to the ps5 console using a USB cable, and press the PS button. This initiates writing the console's (or in this case an esp32's) MAC address to the controller.

To do this, you'll need to include the controller's ip address in the ```ps5.begin()``` function during within the ```setup()``` Arduino function like below where ```1a:2b:3c:01:01:01``` is the MAC address (**note that MAC address must be unicast**):
```
void setup()
{
    ps5.begin("1a:2b:3c:01:01:01");
    Serial.println("Ready.");
}
```

**TLDR:** Connect ps5 controller with phone through bluetooth. Get the controller's bluetooth MAC address (look in About settings of phone). Replace '1a:2b:3c:01:01:01' with your controller's bluetooh MAC. Same can be done with your ps5 console if more convenient.
##
**Note: Only buttons and analog inputs have been tested. Other functions like rumble/lights/IMU might not work, but could possibly be implemented using the 'ps5ViewIncomingBits.ino' example.**

================
File: ps5-esp32-main\examples\ps5Connect\ps5Connect.ino
================
#include <ps5Controller.h>

void setup() {
  Serial.begin(115200);

  ps5.begin("1a:2b:3c:01:01:01"); //replace with MAC address of your controller
  Serial.println("Ready.");
}

void loop() {
  if (ps5.isConnected()) {
    Serial.println("Connected!");
  }

  delay(3000);
}

================
File: ps5-esp32-main\examples\ps5ReceiveData\ps5ReceiveData.ino
================
#include <ps5Controller.h>

void setup() {
  Serial.begin(921600);
  ps5.begin("1a:2b:3c:01:01:01"); //replace with MAC address of your controller
  Serial.println("Ready.");
}

void loop() {
//  while (ps5.isConnected() == false) { // commented out as ps5 controller seems to connect quicker when microcontroller is doing nothing
//    Serial.println("PS5 controller not found");
//    delay(300);
//  }

  while (ps5.isConnected() == true) {
    if (ps5.Right()) Serial.println("Right Button");
    if (ps5.Down()) Serial.println("Down Button");
    if (ps5.Up()) Serial.println("Up Button");
    if (ps5.Left()) Serial.println("Left Button");

    if (ps5.Square()) Serial.println("Square Button");
    if (ps5.Cross()) Serial.println("Cross Button");
    if (ps5.Circle()) Serial.println("Circle Button");
    if (ps5.Triangle()) Serial.println("Triangle Button");

    if (ps5.UpRight()) Serial.println("Up Right");
    if (ps5.DownRight()) Serial.println("Down Right");
    if (ps5.UpLeft()) Serial.println("Up Left");
    if (ps5.DownLeft()) Serial.println("Down Left");

    if (ps5.L1()) Serial.println("L1 Button");
    if (ps5.R1()) Serial.println("R1 Button");

    if (ps5.Share()) Serial.println("Share Button");
    if (ps5.Options()) Serial.println("Options Button");
    if (ps5.L3()) Serial.println("L3 Button");
    if (ps5.R3()) Serial.println("R3 Button");

    if (ps5.PSButton()) Serial.println("PS Button");
    if (ps5.Touchpad()) Serial.println("Touch Pad Button");

    if (ps5.L2()) {
      Serial.printf("L2 button at %d\n", ps5.L2Value());
    }
    if (ps5.R2()) {
      Serial.printf("R2 button at %d\n", ps5.R2Value());
    }

    if (ps5.LStickX()) {
      Serial.printf("Left Stick x at %d\n", ps5.LStickX());
    }
    if (ps5.LStickY()) {
      Serial.printf("Left Stick y at %d\n", ps5.LStickY());
    }
    if (ps5.RStickX()) {
      Serial.printf("Right Stick x at %d\n", ps5.RStickX());
    }
    if (ps5.RStickY()) {
      Serial.printf("Right Stick y at %d\n", ps5.RStickY());
    }

    if (ps5.Charging()) Serial.println("The controller is charging"); //doesn't work
    if (ps5.Audio()) Serial.println("The controller has headphones attached"); //doesn't work
    if (ps5.Mic()) Serial.println("The controller has a mic attached"); //doesn't work

    Serial.printf("Battery Level : %d\n", ps5.Battery()); //doesn't work

    Serial.println();
    // This delay is to make the output more human readable
    // Remove it when you're not trying to see the output
    delay(300);
  }
}

================
File: ps5-esp32-main\examples\ps5SendData\ps5SendData.ino
================
#include <ps5Controller.h>

int r = 255;
int g = 0;
int b = 0;

// Calculates the next value in a rainbow sequence
void nextRainbowColor() {
  if (r > 0 && b == 0) {
    r--;
    g++;
  }
  if (g > 0 && r == 0) {
    g--;
    b++;
  }
  if (b > 0 && g == 0) {
    r++;
    b--;
  }
}

void setup() {
  Serial.begin(115200);

  // Replace the "1a:2b:3c:01:01:01" with the MAC address
  // the controller wants to pair to
  // Note: MAC address must be unicast
  ps5.begin("1a:2b:3c:01:01:01");
  Serial.println("Ready.");
}

void loop() {
  if (ps5.isConnected()) {
    // Sets the color of the controller's front light
    // Params: Red, Green,and Blue
    // See here for details: https://www.w3schools.com/colors/colors_rgb.asp
    ps5.setLed(r, g, b);
    nextRainbowColor();

    // Sets how fast the controller's front light flashes
    // Params: How long the light is on in ms, how long the light is off in ms
    // Range: 0->2550 ms, Set to 0, 0 for the light to remain on
    ps5.setFlashRate(ps5.LStickY() * 10, ps5.RStickY() * 10);

    // Sets the rumble of the controllers
    // Params: Weak rumble intensity, Strong rumble intensity
    // Range: 0->255
    ps5.setRumble(ps5.L2Value(), ps5.R2Value());

    // Sends data set in the above three instructions to the controller
    ps5.sendToController();

    // Don't send data to the controller immediately, will cause buffer overflow
    delay(10);
  }
}

================
File: ps5-esp32-main\examples\ps5ViewIncomingBits\ps5ViewIncomingBits.ino
================
#include <ps5Controller.h>

String lastByteToBinary[64];


String byteToBinary(uint8_t byte) {
  String byteString(byte, BIN);

  for (int i = byteString.length(); i < 8; i++) {
    byteString = '0' + byteString;
  }

  return byteString;
}

/* Print bytes and bits in decreasing order where
   each byte is displayed in its group of 8 bits
   and 4 bytes are printed per line

   Example: Print 4 bytes

            Bit 8  Bit 1 Bit 8  Bit 1 Bit 8  Bit 1 Bit 8  Bit 1
            ˅      ˅     ˅      ˅     ˅      ˅     ˅      ˅
   BYTE 3 : 10101110     11010011     10101110     11010011 : BYTE 0
               ˄            ˄            ˄            ˄
            4th Byte     3rd Byte     2nd Byte     1st Byte
*/
void printBits(uint8_t* packet, int byteCount) {
  for (int byte = byteCount - 4; byte >= 0; byte -= 4) {
    lastByteToBinary[byte + 3] = byteToBinary(packet[byte + 3]);
    lastByteToBinary[byte + 2] = byteToBinary(packet[byte + 2]);
    lastByteToBinary[byte + 1] = byteToBinary(packet[byte + 1]);
    lastByteToBinary[byte] = byteToBinary(packet[byte]);

    Serial.printf("BYTE %d :\t%s %s %s %s\t: BYTE %d\n",
                  (byte + 3),
                  lastByteToBinary[byte + 3],
                  lastByteToBinary[byte + 2],
                  lastByteToBinary[byte + 1],
                  lastByteToBinary[byte],
                  byte);
  }
  Serial.println();
}

void compareBits(uint8_t* packet, int byteCount) {
  for (int byteNum = 0; byteNum < byteCount; byteNum++) {
    if (lastByteToBinary[byteNum] != byteToBinary(packet[byteNum])) {
      Serial.print("changed byte:");
      Serial.println(byteNum);
    }

  }
  Serial.println();
}

void setup() {
  Serial.begin(115200);

  ps5.begin("1a:2b:3c:01:01:01"); //replace with your MAC address
  Serial.println("Ready.");
}

void loop() {
  while (ps5.isConnected() == false) {
    Serial.println("PS5 controller not found");
  }
  delay(1000); //must have this delay for reliable first connection?
  while (ps5.isConnected() == true) {

    printBits(ps5.LatestPacket(), 64);
    delay(300);
    compareBits(ps5.LatestPacket(), 64);
  }

}

================
File: ps5-esp32-main\src\ps5.c
================
#include "ps5.h"

#include <esp_system.h>
#include <string.h>

#include "ps5_int.h"

/********************************************************************************/
/*                              C O N S T A N T S */
/********************************************************************************/

static const uint8_t hid_cmd_payload_ps5_enable[] = {0x43, 0x02};

/********************************************************************************/
/*                         L O C A L    V A R I A B L E S */
/********************************************************************************/

static ps5_connection_callback_t ps5_connection_cb = NULL;
static ps5_connection_object_callback_t ps5_connection_object_cb = NULL;
static void* ps5_connection_object = NULL;

static ps5_event_callback_t ps5_event_cb = NULL;
static ps5_event_object_callback_t ps5_event_object_cb = NULL;
static void* ps5_event_object = NULL;

static bool is_active = false;

/********************************************************************************/
/*                      P U B L I C    F U N C T I O N S */
/********************************************************************************/

/*******************************************************************************
**
** Function         ps5Init
**
** Description      This initializes the bluetooth services to listen
**                  for an incoming ps5 controller connection.
**
**
** Returns          void
**
*******************************************************************************/
void ps5Init() {
  sppInit();
  ps5_l2cap_init_services();
}

/*******************************************************************************
**
** Function         ps5IsConnected
**
** Description      This returns whether a ps5 controller is connected, based
**                  on whether a successful handshake has taken place.
**
**
** Returns          bool
**
*******************************************************************************/
bool ps5IsConnected() { return is_active; }

/*******************************************************************************
**
** Function         ps5Enable
**
** Description      This triggers the ps5 controller to start continually
**                  sending its data.
**
**
** Returns          void
**
*******************************************************************************/
void ps5Enable() {
  uint16_t length = sizeof(hid_cmd_payload_ps5_enable);
  hid_cmd_t hidCommand;

  hidCommand.code = hid_cmd_code_set_report | hid_cmd_code_type_feature;
  hidCommand.identifier = hid_cmd_identifier_ps5_enable;

  memcpy(hidCommand.data, hid_cmd_payload_ps5_enable, length);

  ps5_l2cap_send_hid(&hidCommand, length);
  ps5SetLed(32, 32, 200);
}

/*******************************************************************************
**
** Function         ps5Cmd
**
** Description      Send a command to the ps5 controller.
**
**
** Returns          void
**
*******************************************************************************/
void ps5Cmd(ps5_cmd_t cmd) {
  hid_cmd_t hidCommand = {.data = {0x80, 0x00, 0xFF}};
  uint16_t length = sizeof(hidCommand.data);

  hidCommand.code = hid_cmd_code_set_report | hid_cmd_code_type_output;
  hidCommand.identifier = hid_cmd_identifier_ps5_control;

  hidCommand.data[ps5_control_packet_index_small_rumble] = cmd.smallRumble;  // Small Rumble
  hidCommand.data[ps5_control_packet_index_large_rumble] = cmd.largeRumble;  // Big rumble

  hidCommand.data[ps5_control_packet_index_red] = cmd.r;    // Red
  hidCommand.data[ps5_control_packet_index_green] = cmd.g;  // Green
  hidCommand.data[ps5_control_packet_index_blue] = cmd.b;   // Blue

  // Time to flash bright (255 = 2.5 seconds)
  hidCommand.data[ps5_control_packet_index_flash_on_time] = cmd.flashOn;
  // Time to flash dark (255 = 2.5 seconds)
  hidCommand.data[ps5_control_packet_index_flash_off_time] = cmd.flashOff;

  ps5_l2cap_send_hid(&hidCommand, length);
}

/*******************************************************************************
**
** Function         ps5SetLedOnly
**
** Description      Sets the LEDs on the ps5 controller.
**
**
** Returns          void
**
*******************************************************************************/
void ps5SetLed(uint8_t r, uint8_t g, uint8_t b) {
  ps5_cmd_t cmd = {0};

  cmd.r = r;
  cmd.g = g;
  cmd.b = b;

  ps5Cmd(cmd);
}

/*******************************************************************************
**
** Function         ps5SetOutput
**
** Description      Sets feedback on the ps5 controller.
**
**
** Returns          void
**
*******************************************************************************/
void ps5SetOutput(ps5_cmd_t prevCommand) { ps5Cmd(prevCommand); }

/*******************************************************************************
**
** Function         ps5SetConnectionCallback
**
** Description      Registers a callback for receiving ps5 controller
**                  connection notifications
**
**
** Returns          void
**
*******************************************************************************/
void ps5SetConnectionCallback(ps5_connection_callback_t cb) {
  ps5_connection_cb = cb;
}

/*******************************************************************************
**
** Function         ps5SetConnectionObjectCallback
**
** Description      Registers a callback for receiving ps5 controller
**                  connection notifications
**
**
** Returns          void
**
*******************************************************************************/
void ps5SetConnectionObjectCallback(void* object, ps5_connection_object_callback_t cb) {
  ps5_connection_object_cb = cb;
  ps5_connection_object = object;
}

/*******************************************************************************
**
** Function         ps5SetEventCallback
**
** Description      Registers a callback for receiving ps5 controller events
**
**
** Returns          void
**
*******************************************************************************/
void ps5SetEventCallback(ps5_event_callback_t cb) { ps5_event_cb = cb; }

/*******************************************************************************
**
** Function         ps5SetEventObjectCallback
**
** Description      Registers a callback for receiving ps5 controller events
**
**
** Returns          void
**
*******************************************************************************/
void ps5SetEventObjectCallback(void* object, ps5_event_object_callback_t cb) {
  ps5_event_object_cb = cb;
  ps5_event_object = object;
}

/*******************************************************************************
**
** Function         ps5SetBluetoothMacAddress
**
** Description      Writes a Registers a callback for receiving ps5 controller
*events
**
**
** Returns          void
**
*******************************************************************************/
void ps5SetBluetoothMacAddress(const uint8_t* mac) {
  // The bluetooth MAC address is derived from the base MAC address
  // https://docs.espressif.com/projects/esp-idf/en/stable/api-reference/system/system.html#mac-address
  uint8_t baseMac[6];
  memcpy(baseMac, mac, 6);
  baseMac[5] -= 2;
  esp_base_mac_addr_set(baseMac);
}

/********************************************************************************/
/*                      L O C A L    F U N C T I O N S */
/********************************************************************************/

void ps5ConnectEvent(uint8_t is_connected) {
    if (is_connected) {
        ps5Enable();
    } else {
        is_active = false;
    }
}


void ps5PacketEvent(ps5_t ps5, ps5_event_t event) {
    // Trigger packet event, but if this is the very first packet
    // after connecting, trigger a connection event instead
    if (is_active) {
        if(ps5_event_cb != NULL) {
            ps5_event_cb(ps5, event);
        }

        if (ps5_event_object_cb != NULL && ps5_event_object != NULL) {
            ps5_event_object_cb(ps5_event_object, ps5, event);
        }
    } else {
        is_active = true;

        if(ps5_connection_cb != NULL) {
            ps5_connection_cb(is_active);
        }

        if (ps5_connection_object_cb != NULL && ps5_connection_object != NULL) {
            ps5_connection_object_cb(ps5_connection_object, is_active);
        }
    }
}

================
File: ps5-esp32-main\src\ps5.h
================
#ifndef ps5_H
#define ps5_H

#include <stdbool.h>
#include <stdint.h>

/********************************************************************************/
/*                                  T Y P E S */
/********************************************************************************/

/********************/
/*    A N A L O G   */
/********************/

typedef struct {
  int8_t lx;
  int8_t ly;
  int8_t rx;
  int8_t ry;
} ps5_analog_stick_t;

typedef struct {
  uint8_t l2;
  uint8_t r2;
} ps5_analog_button_t;

typedef struct {
  ps5_analog_stick_t stick;
  ps5_analog_button_t button;
} ps5_analog_t;

/*********************/
/*   B U T T O N S   */
/*********************/

typedef struct {
  uint8_t right : 1;
  uint8_t down : 1;
  uint8_t up : 1;
  uint8_t left : 1;

  uint8_t square : 1;
  uint8_t cross : 1;
  uint8_t circle : 1;
  uint8_t triangle : 1;

  uint8_t upright : 1;
  uint8_t downright : 1;
  uint8_t upleft : 1;
  uint8_t downleft : 1;

  uint8_t l1 : 1;
  uint8_t r1 : 1;
  uint8_t l2 : 1;
  uint8_t r2 : 1;

  uint8_t share : 1;
  uint8_t options : 1;
  uint8_t l3 : 1;
  uint8_t r3 : 1;

  uint8_t ps : 1;
  uint8_t touchpad : 1;
} ps5_button_t;

/*******************************/
/*   S T A T U S   F L A G S   */
/*******************************/

typedef struct {
  uint8_t battery;
  uint8_t charging : 1;
  uint8_t audio : 1;
  uint8_t mic : 1;
} ps5_status_t;

/********************/
/*   S E N S O R S  */
/********************/

typedef struct {
  int16_t z;
} ps5_sensor_gyroscope_t;

typedef struct {
  int16_t x;
  int16_t y;
  int16_t z;
} ps5_sensor_accelerometer_t;

typedef struct {
  ps5_sensor_accelerometer_t accelerometer;
  ps5_sensor_gyroscope_t gyroscope;
} ps5_sensor_t;

/*******************/
/*    O T H E R    */
/*******************/

typedef struct {
  uint8_t smallRumble;
  uint8_t largeRumble;
  uint8_t r, g, b;
  uint8_t flashOn;
  uint8_t flashOff;  // Time to flash bright/dark (255 = 2.5 seconds)
} ps5_cmd_t;

typedef struct {
  ps5_button_t button_down;
  ps5_button_t button_up;
  ps5_analog_t analog_move;
} ps5_event_t;

typedef struct {
  ps5_analog_t analog;
  ps5_button_t button;
  ps5_status_t status;
  ps5_sensor_t sensor;
  uint8_t* latestPacket;
} ps5_t;

/***************************/
/*    C A L L B A C K S    */
/***************************/

typedef void (*ps5_connection_callback_t)(uint8_t isConnected);
typedef void (*ps5_connection_object_callback_t)(void* object, uint8_t isConnected);

typedef void (*ps5_event_callback_t)(ps5_t ps5, ps5_event_t event);
typedef void (*ps5_event_object_callback_t)(void* object, ps5_t ps5, ps5_event_t event);

/********************************************************************************/
/*                             F U N C T I O N S */
/********************************************************************************/

bool ps5IsConnected();
void ps5Init();
void ps5Enable();
void ps5Cmd(ps5_cmd_t ps5_cmd);
void ps5SetConnectionCallback(ps5_connection_callback_t cb);
void ps5SetConnectionObjectCallback(void* object, ps5_connection_object_callback_t cb);
void ps5SetEventCallback(ps5_event_callback_t cb);
void ps5SetEventObjectCallback(void* object, ps5_event_object_callback_t cb);
void ps5SetLed(uint8_t r, uint8_t g, uint8_t b);
void ps5SetOutput(ps5_cmd_t prev_cmd);
void ps5SetBluetoothMacAddress(const uint8_t* mac);
long ps5_l2cap_connect(uint8_t addr[6]);
long ps5_l2cap_reconnect(void);

#endif

================
File: ps5-esp32-main\src\ps5Controller.cpp
================
#include "ps5Controller.h"

#include <esp_bt_defs.h>
#include <esp_bt_main.h>

extern "C" {
#include "ps5.h"
}

#define ESP_BD_ADDR_HEX_PTR(addr) \
  (uint8_t*)addr + 0, (uint8_t*)addr + 1, (uint8_t*)addr + 2, \
  (uint8_t*)addr + 3, (uint8_t*)addr + 4, (uint8_t*)addr + 5

ps5Controller::ps5Controller() {}

bool ps5Controller::begin() {
  ps5SetEventObjectCallback(this, &ps5Controller::_event_callback);
  ps5SetConnectionObjectCallback(this, &ps5Controller::_connection_callback);

  if (!btStarted() && !btStart()) {
    log_e("btStart failed");
    return false;
  }

  esp_bluedroid_status_t btState = esp_bluedroid_get_status();
  if (btState == ESP_BLUEDROID_STATUS_UNINITIALIZED) {
    if (esp_bluedroid_init()) {
      log_e("esp_bluedroid_init failed");
      return false;
    }
  }

  if (btState != ESP_BLUEDROID_STATUS_ENABLED) {
    if (esp_bluedroid_enable()) {
      log_e("esp_bluedroid_enable failed");
      return false;
    }
  }

  ps5Init();
  return true;
}

bool ps5Controller::begin(const char* mac) {
  esp_bd_addr_t addr;
    
  if (sscanf(mac, ESP_BD_ADDR_STR, ESP_BD_ADDR_HEX_PTR(addr)) != ESP_BD_ADDR_LEN) {
    log_e("Could not convert %s\n to a MAC address", mac);
    return false;
  }

  ps5_l2cap_connect(addr);
  // ps5SetBluetoothMacAddress(addr);

  return begin();
}

void ps5Controller::end() {}

bool ps5Controller::isConnected() {
  auto connected = ps5IsConnected();
  static unsigned long tryReconnectAt = 0;
  if (!connected && millis() - tryReconnectAt > 5000UL) {
    tryReconnectAt = millis();
    ps5_l2cap_reconnect();
  }
  return connected;
}

void ps5Controller::setLed(uint8_t r, uint8_t g, uint8_t b) {
  output.r = r;
  output.g = g;
  output.b = b;
}

void ps5Controller::setRumble(uint8_t small, uint8_t large) {
  output.smallRumble = small;
  output.largeRumble = large;
}

void ps5Controller::setFlashRate(uint8_t onTime, uint8_t offTime) {
  output.flashOn = onTime / 10;
  output.flashOff = offTime / 10;
}

void ps5Controller::sendToController() { ps5SetOutput(output); }

void ps5Controller::attach(callback_t callback) { _callback_event = callback; }

void ps5Controller::attachOnConnect(callback_t callback) {
  _callback_connect = callback;
}

void ps5Controller::attachOnDisconnect(callback_t callback) {
  _callback_disconnect = callback;
}

void ps5Controller::_event_callback(
  void* object, ps5_t data, ps5_event_t event) {
  ps5Controller* This = (ps5Controller*)object;

  memcpy(&This->data, &data, sizeof(ps5_t));
  memcpy(&This->event, &event, sizeof(ps5_event_t));

  if (This->_callback_event) {
    This->_callback_event();
  }
}

void ps5Controller::_connection_callback(void* object, uint8_t isConnected) {
  ps5Controller* This = (ps5Controller*)object;

  if (isConnected) {
    delay(250);  // ToDo: figure out how to know when the channel is free again
                 // so this delay can be removed

    if (This->_callback_connect) {
      This->_callback_connect();
    }
  }
  else {
    if (This->_callback_disconnect) {
      This->_callback_disconnect();
    }
  }
}

#if !defined(NO_GLOBAL_INSTANCES)
ps5Controller ps5;
#endif

================
File: ps5-esp32-main\src\ps5Controller.h
================
#ifndef ps5Controller_h
#define ps5Controller_h

#include "Arduino.h"

extern "C" {
#include "ps5.h"
}

class ps5Controller {
 public:
  typedef void (*callback_t)();

  ps5_t data;
  ps5_event_t event;
  ps5_cmd_t output;

  ps5Controller();

  bool begin();
  bool begin(const char* mac);
  void end();

  bool isConnected();

  void setLed(uint8_t r, uint8_t g, uint8_t b);
  void setRumble(uint8_t small, uint8_t large);
  void setFlashRate(uint8_t onTime, uint8_t offTime);

  void sendToController();

  void attach(callback_t callback);
  void attachOnConnect(callback_t callback);
  void attachOnDisconnect(callback_t callback);

  uint8_t* LatestPacket() { return data.latestPacket; }

public:
  bool Right() { return data.button.right; }
  bool Down() { return data.button.down; }
  bool Up() { return data.button.up; }
  bool Left() { return data.button.left; }

  bool Square() { return data.button.square; }
  bool Cross() { return data.button.cross; }
  bool Circle() { return data.button.circle; }
  bool Triangle() { return data.button.triangle; }

  bool UpRight() { return data.button.upright; }
  bool DownRight() { return data.button.downright; }
  bool UpLeft() { return data.button.upleft; }
  bool DownLeft() { return data.button.downleft; }

  bool L1() { return data.button.l1; }
  bool R1() { return data.button.r1; }
  bool L2() { return data.button.l2; }
  bool R2() { return data.button.r2; }

  bool Share() { return data.button.share; }
  bool Options() { return data.button.options; }
  bool L3() { return data.button.l3; }
  bool R3() { return data.button.r3; }

  bool PSButton() { return data.button.ps; }
  bool Touchpad() { return data.button.touchpad; }

  uint8_t L2Value() { return data.analog.button.l2; }
  uint8_t R2Value() { return data.analog.button.r2; }

  int8_t LStickX() { return data.analog.stick.lx; }
  int8_t LStickY() { return data.analog.stick.ly; }
  int8_t RStickX() { return data.analog.stick.rx; }
  int8_t RStickY() { return data.analog.stick.ry; }

  uint8_t Battery() { return data.status.battery; }
  bool Charging() { return data.status.charging; }
  bool Audio() { return data.status.audio; }
  bool Mic() { return data.status.mic; }

 private:
  static void _event_callback(void* object, ps5_t data, ps5_event_t event);
  static void _connection_callback(void* object, uint8_t isConnected);

  callback_t _callback_event = nullptr;
  callback_t _callback_connect = nullptr;
  callback_t _callback_disconnect = nullptr;
};

#ifndef NO_GLOBAL_INSTANCES
extern ps5Controller ps5;
#endif

#endif

================
File: ps5-esp32-main\src\ps5_int.h
================
#ifndef ps5_INT_H
#define ps5_INT_H

#include "sdkconfig.h"

/** Check if the project is configured properly */
#ifndef ARDUINO_ARCH_ESP32

/** Check the configured blueooth mode */
#ifdef CONFIG_BTDM_CONTROLLER_MODE_BTDM
#define BT_MODE ESP_BT_MODE_BTDM
#elif defined CONFIG_BTDM_CONTROLLER_MODE_BR_EDR_ONLY
#define BT_MODE ESP_BT_MODE_CLASSIC_BT
#else
#error \
  "The selected Bluetooth controller mode is not supported by the ESP32-ps5 module"
#endif

#endif  // ARDUINO_ARCH_ESP32

/* Detect ESP-IDF releases */
#if __has_include("esp_idf_version.h")
#include <esp_idf_version.h>

#else

/* Detect Arduino releases */
#if __has_include("core_version.h")
#include <core_version.h>
#endif


/* Arduino releases using IDF v3.2.3 */
#if defined(ARDUINO_ESP32_RELEASE_1_0_4) || defined(ARDUINO_ESP32_RELEASE_1_0_3)
#define ESP_IDF_VERSION_MAJOR 3
#define ESP_IDF_VERSION_MINOR 2
#define ESP_IDF_VERSION_PATCH 3
#endif

/* Arduino releases using IDF v3.2.2 */
#if defined(ARDUINO_ESP32_RELEASE_1_0_3) || defined(ARDUINO_ESP32_RELEASE_1_0_2) || defined(ARDUINO_ESP32_RELEASE_1_0_1) || defined(ARDUINO_ESP32_RELEASE_1_0_0)
#define ESP_IDF_VERSION_MAJOR 3
#define ESP_IDF_VERSION_MINOR 2
#define ESP_IDF_VERSION_PATCH 2
#endif

// Macro to convert IDF version number into an integer
#define ESP_IDF_VERSION_VAL(major, minor, patch) ((major << 16) | (minor << 8) | (patch))

// Current IDF version, as an integer
#define ESP_IDF_VERSION  ESP_IDF_VERSION_VAL(ESP_IDF_VERSION_MAJOR, \
                                             ESP_IDF_VERSION_MINOR, \
                                             ESP_IDF_VERSION_PATCH)

#endif // __has_include("esp_idf_version.h")

/** ESP-IDF compatibility configuration option choices */
#define IDF_COMPATIBILITY_MASTER_21165ED 3
#define IDF_COMPATIBILITY_MASTER_D9CE0BB 2
#define IDF_COMPATIBILITY_MASTER_21AF1D7 1

#ifndef CONFIG_IDF_COMPATIBILITY
#define CONFIG_IDF_COMPATIBILITY IDF_COMPATIBILITY_MASTER_21165ED
#endif

/** Size of the output report buffer for the Dualshock and Navigation
 * controllers */
#define ps5_SEND_BUFFER_SIZE 77
#define ps5_HID_BUFFER_SIZE 50

/********************************************************************************/
/*                         S H A R E D   T Y P E S */
/********************************************************************************/

enum hid_cmd_code {
  hid_cmd_code_set_report = 0x50,
  hid_cmd_code_type_output = 0x02,
  hid_cmd_code_type_feature = 0x03
};

enum hid_cmd_identifier {
  hid_cmd_identifier_ps5_enable = 0xF4,
  hid_cmd_identifier_ps5_control = 0x11
};

typedef struct {
  uint8_t code;
  uint8_t identifier;
  uint8_t data[ps5_SEND_BUFFER_SIZE];
} hid_cmd_t;

enum ps5_control_packet_index {
  ps5_control_packet_index_small_rumble = 5,
  ps5_control_packet_index_large_rumble = 6,

  ps5_control_packet_index_red = 7,
  ps5_control_packet_index_green = 8,
  ps5_control_packet_index_blue = 9,

  ps5_control_packet_index_flash_on_time = 10,
  ps5_control_packet_index_flash_off_time = 11
};

/********************************************************************************/
/*                     C A L L B A C K   F U N C T I O N S */
/********************************************************************************/

void ps5ConnectEvent(uint8_t isConnected);
void ps5PacketEvent(ps5_t ps5, ps5_event_t event);

/********************************************************************************/
/*                      P A R S E R   F U N C T I O N S */
/********************************************************************************/

void parsePacket(uint8_t* packet);

/********************************************************************************/
/*                          S P P   F U N C T I O N S */
/********************************************************************************/

void sppInit();

/********************************************************************************/
/*                          G A P   F U N C T I O N S */
/********************************************************************************/

void ps5_l2cap_init_services();
void ps5_l2cap_deinit_services();
void ps5_l2cap_send_hid(hid_cmd_t *hid_cmd, uint8_t len);

#endif

================
File: ps5-esp32-main\src\ps5_l2cap.c
================
#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include "ps5.h"
#include "ps5_int.h"
#include "esp_log.h"
#include "esp_bt.h"
#include "esp_bt_main.h"
#include "esp_gap_bt_api.h"
#include "stack/gap_api.h"
#include "stack/bt_types.h"
#include "stack/l2c_api.h"
#include "osi/allocator.h"

#define  ps5_TAG "ps5_L2CAP"



/********************************************************************************/
/*              L O C A L    F U N C T I O N     P R O T O T Y P E S            */
/********************************************************************************/

static void ps5_l2cap_init_service(const char *name, uint16_t psm, uint8_t security_id);
static void ps5_l2cap_deinit_service(const char *name, uint16_t psm);
static void ps5_l2cap_connect_ind_cback(BD_ADDR  bd_addr, uint16_t l2cap_cid, uint16_t psm, uint8_t l2cap_id);
static void ps5_l2cap_connect_cfm_cback(uint16_t l2cap_cid, uint16_t result);
static void ps5_l2cap_config_ind_cback(uint16_t l2cap_cid, tL2CAP_CFG_INFO *p_cfg);
static void ps5_l2cap_config_cfm_cback(uint16_t l2cap_cid, tL2CAP_CFG_INFO *p_cfg);
static void ps5_l2cap_disconnect_ind_cback(uint16_t l2cap_cid, bool ack_needed);
static void ps5_l2cap_disconnect_cfm_cback(uint16_t l2cap_cid, uint16_t result);
static void ps5_l2cap_data_ind_cback(uint16_t l2cap_cid, BT_HDR *p_msg);
static void ps5_l2cap_congest_cback(uint16_t cid, bool congested);


/********************************************************************************/
/*                         L O C A L    V A R I A B L E S                       */
/********************************************************************************/

static const tL2CAP_APPL_INFO dyn_info = {
    ps5_l2cap_connect_ind_cback,
    ps5_l2cap_connect_cfm_cback,
    NULL,
    ps5_l2cap_config_ind_cback,
    ps5_l2cap_config_cfm_cback,
    ps5_l2cap_disconnect_ind_cback,
    ps5_l2cap_disconnect_cfm_cback,
    NULL,
    ps5_l2cap_data_ind_cback,
    ps5_l2cap_congest_cback,
    NULL
};

static tL2CAP_CFG_INFO ps5_cfg_info;

bool is_connected = false;
static BD_ADDR g_bd_addr;
uint16_t l2cap_control_channel = 0;
uint16_t l2cap_interrupt_channel = 0;


/********************************************************************************/
/*                      P U B L I C    F U N C T I O N S                        */
/********************************************************************************/

/*******************************************************************************
**
** Function         ps5_l2cap_init_services
**
** Description      This function initialises the required L2CAP services.
**
** Returns          void
**
*******************************************************************************/
void ps5_l2cap_init_services() {
    ps5_l2cap_init_service("ps5-HIDC", BT_PSM_HID_CONTROL, BTM_SEC_SERVICE_FIRST_EMPTY);
    ps5_l2cap_init_service("ps5-HIDI", BT_PSM_HID_INTERRUPT, BTM_SEC_SERVICE_FIRST_EMPTY + 1);
}

/*******************************************************************************
**
** Function         ps5_l2cap_deinit_services
**
** Description      This function deinitialises the required L2CAP services.
**
** Returns          void
**
*******************************************************************************/
void ps5_l2cap_deinit_services() {
    ps5_l2cap_deinit_service("ps5-HIDC", BT_PSM_HID_CONTROL);
    ps5_l2cap_deinit_service("ps5-HIDI", BT_PSM_HID_INTERRUPT);
}

/*******************************************************************************
**
** Function         ps5_l2cap_connect
**
** Description      This function deinitialises the required L2CAP services.
**
** Returns          Result of connection reqiest
**
*******************************************************************************/
long ps5_l2cap_connect(BD_ADDR addr) {
    memmove(g_bd_addr, addr, sizeof(BD_ADDR));

    return ps5_l2cap_reconnect();
}

/*******************************************************************************
**
** Function         ps5_l2cap_reconnect
**
** Description      This function deinitialises the required L2CAP services.
**
** Returns          Result of connection reqiest
**
*******************************************************************************/
long ps5_l2cap_reconnect(void) {
    long ret;
    ret = L2CA_CONNECT_REQ(BT_PSM_HID_CONTROL, g_bd_addr, NULL, NULL);
    ESP_LOGE(ps5_TAG, "L2CA_CONNECT_REQ ret=%d\n", ret);
    if (ret == 0) {
        return -1;
    }
    l2cap_control_channel = ret;

    // is_connected = false;

    return ret;
}


/*******************************************************************************
**
** Function         ps5_l2cap_send_hid
**
** Description      This function sends the HID command using the L2CAP service.
**
** Returns          void
**
*******************************************************************************/
void ps5_l2cap_send_hid( hid_cmd_t *hid_cmd, uint8_t len ) {
    uint8_t result;
    BT_HDR *p_buf;

    p_buf = (BT_HDR *)osi_malloc(BT_DEFAULT_BUFFER_SIZE);

    if (!p_buf) {
        ESP_LOGE(ps5_TAG, "[%s] allocating buffer for sending the command failed", __func__);
    }

    p_buf->length = len + ( sizeof(*hid_cmd) - sizeof(hid_cmd->data) );
    p_buf->offset = L2CAP_MIN_OFFSET;

    memcpy((uint8_t *)(p_buf + 1) + p_buf->offset, (uint8_t*)hid_cmd, p_buf->length);

    if (l2cap_control_channel == 0) {
        ESP_LOGE(ps5_TAG, "[%s] l2cap_control_channel not initialized.", __func__);
    }
    result = L2CA_DataWrite(l2cap_control_channel, p_buf );

    if (result == L2CAP_DW_SUCCESS)
        ESP_LOGI(ps5_TAG, "[%s] sending command: success", __func__);

    if (result == L2CAP_DW_CONGESTED)
        ESP_LOGW(ps5_TAG, "[%s] sending command: congested", __func__);

    if (result == L2CAP_DW_FAILED)
        ESP_LOGE(ps5_TAG, "[%s] sending command: failed", __func__);
}


/********************************************************************************/
/*                      L O C A L    F U N C T I O N S                          */
/********************************************************************************/

/*******************************************************************************
**
** Function         ps5_l2cap_init_service
**
** Description      This registers the specified bluetooth service in order
**                  to listen for incoming connections.
**
** Returns          void
**
*******************************************************************************/
static void ps5_l2cap_init_service(const char *name, uint16_t psm, uint8_t security_id) {
    // log_i("init services");
    /* Register the PSM for incoming connections */
    if (!L2CA_Register(psm, (tL2CAP_APPL_INFO *) &dyn_info)) {
        ESP_LOGE(ps5_TAG, "%s Registering service %s failed", __func__, name);
        return;
    }

    /* Register with the Security Manager for our specific security level (none) */
    if (!BTM_SetSecurityLevel (false, name, security_id, 0, psm, 0, 0)) {
        ESP_LOGE (ps5_TAG, "%s Registering security service %s failed", __func__, name);\
        return;
    }

    ESP_LOGI(ps5_TAG, "[%s] Service %s Initialized", __func__, name);
}

/*******************************************************************************
**
** Function         ps5_l2cap_deinit_service
**
** Description      This deregisters the specified bluetooth service.
**
** Returns          void
**
*******************************************************************************/
static void ps5_l2cap_deinit_service(const char *name, uint16_t psm ) {
    /* Deregister the PSM from incoming connections */
    L2CA_Deregister(psm);
    ESP_LOGI(ps5_TAG, "[%s] Service %s Deinitialized", __func__, name);
}


/*******************************************************************************
**
** Function         ps5_l2cap_connect_ind_cback
**
** Description      This the L2CAP inbound connection indication callback function.
**
** Returns          void
**
*******************************************************************************/
static void ps5_l2cap_connect_ind_cback (BD_ADDR  bd_addr, uint16_t l2cap_cid, uint16_t psm, uint8_t l2cap_id) {
    ESP_LOGI(ps5_TAG, "[%s] bd_addr: %s\n  l2cap_cid: 0x%02x\n  psm: %d\n  id: %d", __func__, bd_addr, l2cap_cid, psm, l2cap_id );

    /* Send connection pending response to the L2CAP layer. */
    L2CA_CONNECT_RSP(bd_addr, l2cap_id, l2cap_cid, L2CAP_CONN_PENDING, L2CAP_CONN_PENDING, NULL, NULL);

    /* Send response to the L2CAP layer. */
    L2CA_CONNECT_RSP(bd_addr, l2cap_id, l2cap_cid, L2CAP_CONN_OK, L2CAP_CONN_OK, NULL, NULL);

    /* Send a Configuration Request. */
    L2CA_CONFIG_REQ(l2cap_cid, &ps5_cfg_info);

    if (psm == BT_PSM_HID_CONTROL) {
        l2cap_control_channel = l2cap_cid;
    } else if (psm == BT_PSM_HID_INTERRUPT) {
        l2cap_interrupt_channel = l2cap_cid;
    }
}


/*******************************************************************************
**
** Function         ps5_l2cap_connect_cfm_cback
**
** Description      This is the L2CAP connect confirmation callback function.
**
**
** Returns          void
**
*******************************************************************************/
static void ps5_l2cap_connect_cfm_cback(uint16_t l2cap_cid, uint16_t result) {
    ESP_LOGI(ps5_TAG, "[%s] l2cap_cid: 0x%02x\n  result: %d", __func__, l2cap_cid, result );
}


/*******************************************************************************
**
** Function         ps5_l2cap_config_cfm_cback
**
** Description      This is the L2CAP config confirmation callback function.
**
**
** Returns          void
**
*******************************************************************************/
void ps5_l2cap_config_cfm_cback(uint16_t l2cap_cid, tL2CAP_CFG_INFO *p_cfg) {
    ESP_LOGI(ps5_TAG, "[%s] l2cap_cid: 0x%02x\n  p_cfg->result: %d", __func__, l2cap_cid, p_cfg->result );

    /* The ps5 controller is connected after    */
    /* receiving the second config confirmation */
    bool prev_is_connected = is_connected;
    is_connected = l2cap_cid == l2cap_interrupt_channel;
    if (prev_is_connected != is_connected) {
        ps5ConnectEvent(is_connected);
    }
}


/*******************************************************************************
**
** Function         ps5_l2cap_config_ind_cback
**
** Description      This is the L2CAP config indication callback function.
**
**
** Returns          void
**
*******************************************************************************/
void ps5_l2cap_config_ind_cback(uint16_t l2cap_cid, tL2CAP_CFG_INFO *p_cfg) {
    ESP_LOGI(ps5_TAG, "[%s] l2cap_cid: 0x%02x\n  p_cfg->result: %d\n  p_cfg->mtu_present: %d\n  p_cfg->mtu: %d", __func__, l2cap_cid, p_cfg->result, p_cfg->mtu_present, p_cfg->mtu );

    p_cfg->result = L2CAP_CFG_OK;

    L2CA_ConfigRsp(l2cap_cid, p_cfg);
}


/*******************************************************************************
**
** Function         ps5_l2cap_disconnect_ind_cback
**
** Description      This is the L2CAP disconnect indication callback function.
**
**
** Returns          void
**
*******************************************************************************/
void ps5_l2cap_disconnect_ind_cback(uint16_t l2cap_cid, bool ack_needed) {
    ESP_LOGI(ps5_TAG, "[%s] l2cap_cid: 0x%02x\n  ack_needed: %d", __func__, l2cap_cid, ack_needed );
    is_connected = false;
    if (ack_needed) {
        L2CA_DisconnectRsp(l2cap_cid);
    }
    ps5ConnectEvent(is_connected);
}


/*******************************************************************************
**
** Function         ps5_l2cap_disconnect_cfm_cback
**
** Description      This is the L2CAP disconnect confirm callback function.
**
**
** Returns          void
**
*******************************************************************************/
static void ps5_l2cap_disconnect_cfm_cback(uint16_t l2cap_cid, uint16_t result) {
    ESP_LOGI(ps5_TAG, "[%s] l2cap_cid: 0x%02x\n  result: %d", __func__, l2cap_cid, result );
}


/*******************************************************************************
**
** Function         ps5_l2cap_data_ind_cback
**
** Description      This is the L2CAP data indication callback function.
**
**
** Returns          void
**
*******************************************************************************/
static void ps5_l2cap_data_ind_cback(uint16_t l2cap_cid, BT_HDR *p_buf) {
    if (p_buf->length > 2) {
        parsePacket(p_buf->data);
    }

    osi_free(p_buf);
}


/*******************************************************************************
**
** Function         ps5_l2cap_congest_cback
**
** Description      This is the L2CAP congestion callback function.
**
** Returns          void
**
*******************************************************************************/
static void ps5_l2cap_congest_cback (uint16_t l2cap_cid, bool congested) {
    ESP_LOGI(ps5_TAG, "[%s] l2cap_cid: 0x%02x\n  congested: %d", __func__, l2cap_cid, congested );
}

================
File: ps5-esp32-main\src\ps5_parser.c
================
#include <esp_system.h>

#include "ps5.h"
#include "ps5_int.h"

/********************************************************************************/
/*                            L O C A L    T Y P E S */
/********************************************************************************/

enum ps5_packet_index {
  packet_index_analog_stick_lx = 11,
  packet_index_analog_stick_ly = 12,
  packet_index_analog_stick_rx = 13,
  packet_index_analog_stick_ry = 14,

  packet_index_button_standard = 15,
  packet_index_button_extra = 16,
  packet_index_button_ps = 17,

  packet_index_analog_l2 = 18,
  packet_index_analog_r2 = 19,

  packet_index_status = 42
};

enum ps5_button_mask {
  button_mask_up = 0,
  button_mask_right = 0b00000010,
  button_mask_down = 0b00000100,
  button_mask_left = 0b00000110,

  button_mask_upright = 0b00000001,
  button_mask_downright = 0b00000011,
  button_mask_upleft = 0b00000111,
  button_mask_downleft = 0b00000101,

  button_mask_direction = 0b00001111,

  button_mask_square = 0b00010000,
  button_mask_cross = 0b00100000,
  button_mask_circle = 0b01000000,
  button_mask_triangle = 0b10000000,

  button_mask_l1 = 0b00000001,
  button_mask_r1 = 0b00000010,
  button_mask_l2 = 0b00000100,
  button_mask_r2 = 0b00001000,

  button_mask_share = 0b00010000,
  button_mask_options = 0b00100000,

  button_mask_l3 = 0b01000000,
  button_mask_r3 = 0b10000000,

  button_mask_ps = 0b01,
  button_mask_touchpad = 0b10
};

enum ps5_status_mask {
  ps5_status_mask_battery = 0b00001111,
  ps5_status_mask_charging = 0b00010000,
  ps5_status_mask_audio = 0b00100000,
  ps5_status_mask_mic = 0b01000000,
};

/********************************************************************************/
/*              L O C A L    F U N C T I O N     P R O T O T Y P E S */
/********************************************************************************/

ps5_sensor_t parsePacketSensor(uint8_t* packet);
ps5_status_t parsePacketStatus(uint8_t* packet);
ps5_analog_stick_t parsePacketAnalogStick(uint8_t* packet);
ps5_analog_button_t parsePacketAnalogButton(uint8_t* packet);
ps5_button_t parsePacketButtons(uint8_t* packet);
ps5_event_t parseEvent(ps5_t prev, ps5_t cur);

/********************************************************************************/
/*                         L O C A L    V A R I A B L E S */
/********************************************************************************/

static ps5_t ps5;
static ps5_event_callback_t ps5_event_cb = NULL;

/********************************************************************************/
/*                      P U B L I C    F U N C T I O N S */
/********************************************************************************/
void parserSetEventCb(ps5_event_callback_t cb) { ps5_event_cb = cb; }

void parsePacket(uint8_t* packet) {
  ps5_t prev_ps5 = ps5;

  ps5.button = parsePacketButtons(packet);
  ps5.analog.stick = parsePacketAnalogStick(packet);
  ps5.analog.button = parsePacketAnalogButton(packet);
  // ps5.sensor = parsePacketSensor(packet);
  ps5.status = parsePacketStatus(packet);
  ps5.latestPacket = packet;

  ps5_event_t ps5Event = parseEvent(prev_ps5, ps5);

  ps5PacketEvent(ps5, ps5Event);
}

/********************************************************************************/
/*                      L O C A L    F U N C T I O N S */
/********************************************************************************/

/******************/
/*    E V E N T   */
/******************/
ps5_event_t parseEvent(ps5_t prev, ps5_t cur) {
  ps5_event_t ps5Event;

  /* Button down events */
  ps5Event.button_down.right = !prev.button.right && cur.button.right;
  ps5Event.button_down.down = !prev.button.down && cur.button.down;
  ps5Event.button_down.up = !prev.button.up && cur.button.up;
  ps5Event.button_down.left = !prev.button.left && cur.button.left;

  ps5Event.button_down.square = !prev.button.square && cur.button.square;
  ps5Event.button_down.cross = !prev.button.cross && cur.button.cross;
  ps5Event.button_down.circle = !prev.button.circle && cur.button.circle;
  ps5Event.button_down.triangle = !prev.button.triangle && cur.button.triangle;

  ps5Event.button_down.upright = !prev.button.upright && cur.button.upright;
  ps5Event.button_down.downright = !prev.button.downright && cur.button.downright;
  ps5Event.button_down.upleft = !prev.button.upleft && cur.button.upleft;
  ps5Event.button_down.downleft = !prev.button.downleft && cur.button.downleft;

  ps5Event.button_down.l1 = !prev.button.l1 && cur.button.l1;
  ps5Event.button_down.r1 = !prev.button.r1 && cur.button.r1;
  ps5Event.button_down.l2 = !prev.button.l2 && cur.button.l2;
  ps5Event.button_down.r2 = !prev.button.r2 && cur.button.r2;

  ps5Event.button_down.share = !prev.button.share && cur.button.share;
  ps5Event.button_down.options = !prev.button.options && cur.button.options;
  ps5Event.button_down.l3 = !prev.button.l3 && cur.button.l3;
  ps5Event.button_down.r3 = !prev.button.r3 && cur.button.r3;

  ps5Event.button_down.ps = !prev.button.ps && cur.button.ps;
  ps5Event.button_down.touchpad = !prev.button.touchpad && cur.button.touchpad;

  /* Button up events */
  ps5Event.button_down.right = prev.button.right && !cur.button.right;
  ps5Event.button_down.down = prev.button.down && !cur.button.down;
  ps5Event.button_down.up = prev.button.up && !cur.button.up;
  ps5Event.button_down.left = prev.button.left && !cur.button.left;

  ps5Event.button_down.square = prev.button.square && !cur.button.square;
  ps5Event.button_down.cross = prev.button.cross && !cur.button.cross;
  ps5Event.button_down.circle = prev.button.circle && !cur.button.circle;
  ps5Event.button_down.triangle = prev.button.triangle && !cur.button.triangle;

  ps5Event.button_down.upright = prev.button.upright && !cur.button.upright;
  ps5Event.button_down.downright = prev.button.downright && !cur.button.downright;
  ps5Event.button_down.upleft = prev.button.upleft && !cur.button.upleft;
  ps5Event.button_down.downleft = prev.button.downleft && !cur.button.downleft;

  ps5Event.button_down.l1 = prev.button.l1 && !cur.button.l1;
  ps5Event.button_down.r1 = prev.button.r1 && !cur.button.r1;
  ps5Event.button_down.l2 = prev.button.l2 && !cur.button.l2;
  ps5Event.button_down.r2 = prev.button.r2 && !cur.button.r2;

  ps5Event.button_down.share = prev.button.share && !cur.button.share;
  ps5Event.button_down.options = prev.button.options && !cur.button.options;
  ps5Event.button_down.l3 = prev.button.l3 && !cur.button.l3;
  ps5Event.button_down.r3 = prev.button.r3 && !cur.button.r3;

  ps5Event.button_down.ps = prev.button.ps && !cur.button.ps;
  ps5Event.button_down.touchpad = prev.button.touchpad && !cur.button.touchpad;

  ps5Event.analog_move.stick.lx = cur.analog.stick.lx != 0;
  ps5Event.analog_move.stick.ly = cur.analog.stick.ly != 0;
  ps5Event.analog_move.stick.rx = cur.analog.stick.rx != 0;
  ps5Event.analog_move.stick.ry = cur.analog.stick.ry != 0;

  return ps5Event;
}

/********************/
/*    A N A L O G   */
/********************/
ps5_analog_stick_t parsePacketAnalogStick(uint8_t* packet) {
  ps5_analog_stick_t ps5AnalogStick;

  const uint8_t offset = 128;

  ps5AnalogStick.lx = packet[packet_index_analog_stick_lx] - offset;
  ps5AnalogStick.ly = -packet[packet_index_analog_stick_ly] + offset - 1;
  ps5AnalogStick.rx = packet[packet_index_analog_stick_rx] - offset;
  ps5AnalogStick.ry = -packet[packet_index_analog_stick_ry] + offset - 1;

  return ps5AnalogStick;
}

ps5_analog_button_t parsePacketAnalogButton(uint8_t* packet) {
  ps5_analog_button_t ps5AnalogButton;

  ps5AnalogButton.l2 = packet[packet_index_analog_l2];
  ps5AnalogButton.r2 = packet[packet_index_analog_r2];

  return ps5AnalogButton;
}

/*********************/
/*   B U T T O N S   */
/*********************/

ps5_button_t parsePacketButtons(uint8_t* packet) {
  ps5_button_t ps5_button;
  uint8_t frontBtnData = packet[packet_index_button_standard];
  uint8_t extraBtnData = packet[packet_index_button_extra];
  uint8_t psBtnData = packet[packet_index_button_ps];
  uint8_t directionBtnsOnly = button_mask_direction & frontBtnData;

  ps5_button.up = directionBtnsOnly == button_mask_up;
  ps5_button.right = directionBtnsOnly == button_mask_right;
  ps5_button.down = directionBtnsOnly == button_mask_down;
  ps5_button.left = directionBtnsOnly == button_mask_left;

  ps5_button.upright = directionBtnsOnly == button_mask_upright;
  ps5_button.upleft = directionBtnsOnly == button_mask_upleft;
  ps5_button.downright = directionBtnsOnly == button_mask_downright;
  ps5_button.downleft = directionBtnsOnly == button_mask_downleft;

  ps5_button.triangle = (frontBtnData & button_mask_triangle) ? true : false;
  ps5_button.circle = (frontBtnData & button_mask_circle) ? true : false;
  ps5_button.cross = (frontBtnData & button_mask_cross) ? true : false;
  ps5_button.square = (frontBtnData & button_mask_square) ? true : false;

  ps5_button.l1 = (extraBtnData & button_mask_l1) ? true : false;
  ps5_button.r1 = (extraBtnData & button_mask_r1) ? true : false;
  ps5_button.l2 = (extraBtnData & button_mask_l2) ? true : false;
  ps5_button.r2 = (extraBtnData & button_mask_r2) ? true : false;

  ps5_button.share = (extraBtnData & button_mask_share) ? true : false;
  ps5_button.options = (extraBtnData & button_mask_options) ? true : false;
  ps5_button.l3 = (extraBtnData & button_mask_l3) ? true : false;
  ps5_button.r3 = (extraBtnData & button_mask_r3) ? true : false;

  ps5_button.ps = (psBtnData & button_mask_ps) ? true : false;
  ps5_button.touchpad = (psBtnData & button_mask_touchpad) ? true : false;

  return ps5_button;
}

/*******************************/
/*   S T A T U S   F L A G S   */
/*******************************/
ps5_status_t parsePacketStatus(uint8_t* packet) {
  ps5_status_t ps5Status;

  ps5Status.battery = packet[packet_index_status] & ps5_status_mask_battery;
  ps5Status.charging = packet[packet_index_status] & ps5_status_mask_charging ? true : false;
  ps5Status.audio = packet[packet_index_status] & ps5_status_mask_audio ? true : false;
  ps5Status.mic = packet[packet_index_status] & ps5_status_mask_mic ? true : false;

  return ps5Status;
}

/********************/
/*   S E N S O R S  */
/********************/
ps5_sensor_t parsePacketSensor(uint8_t* packet) {
  ps5_sensor_t ps5Sensor;
  /*
      const uint16_t offset = 0x200;

      ps5Sensor.accelerometer.x = (packet[packet_index_sensor_accelerometer_x] << 8) +
     packet[packet_index_sensor_accelerometer_x+1] - offset;
      ps5Sensor.accelerometer.y = (packet[packet_index_sensor_accelerometer_y] << 8) +
     packet[packet_index_sensor_accelerometer_y+1] - offset;
      ps5Sensor.accelerometer.z = (packet[packet_index_sensor_accelerometer_z] << 8) +
     packet[packet_index_sensor_accelerometer_z+1] - offset;
      ps5Sensor.gyroscope.z     = (packet[packet_index_sensor_gyroscope_z]
     << 8) + packet[packet_index_sensor_gyroscope_z+1]     - offset;
  */
  return ps5Sensor;
}

================
File: ps5-esp32-main\src\ps5_spp.c
================
#include "esp_bt.h"
#include "esp_bt_device.h"
#include "esp_bt_main.h"
#include "esp_gap_bt_api.h"
#include "esp_log.h"
#include "esp_spp_api.h"
#include "ps5.h"
#include "ps5_int.h"

#define ps5_TAG "ps5_SPP"

/********************************************************************************/
/*              L O C A L    F U N C T I O N     P R O T O T Y P E S            */
/********************************************************************************/
static void sppCallback(esp_spp_cb_event_t event, esp_spp_cb_param_t* param);

/********************************************************************************/
/*                      P U B L I C    F U N C T I O N S                        */
/********************************************************************************/

/*******************************************************************************
**
** Function         sppInit
**
** Description      Initialise the SPP server to allow to be connected to
**
** Returns          void
**
*******************************************************************************/
void sppInit() {
  esp_err_t ret;

#ifndef ARDUINO_ARCH_ESP32
  esp_bt_controller_config_t bt_cfg = BT_CONTROLLER_INIT_CONFIG_DEFAULT();
  if ((ret = esp_bt_controller_init(&bt_cfg)) != ESP_OK) {
    ESP_LOGE(ps5_TAG, "%s initialize controller failed: %s\n", __func__, esp_err_to_name(ret));
    return;
  }

  if ((ret = esp_bt_controller_enable(BT_MODE)) != ESP_OK) {
    ESP_LOGE(ps5_TAG, "%s enable controller failed: %s\n", __func__, esp_err_to_name(ret));
    return;
  }

  if ((ret = esp_bluedroid_init()) != ESP_OK) {
    ESP_LOGE(ps5_TAG, "%s initialize bluedroid failed: %s\n", __func__, esp_err_to_name(ret));
    return;
  }

  if ((ret = esp_bluedroid_enable()) != ESP_OK) {
    ESP_LOGE(ps5_TAG, "%s enable bluedroid failed: %s\n", __func__, esp_err_to_name(ret));
    return;
  }
#endif

  if ((ret = esp_spp_register_callback(sppCallback)) != ESP_OK) {
    ESP_LOGE(ps5_TAG, "%s spp register failed: %s\n", __func__, esp_err_to_name(ret));
    return;
  }

  if ((ret = esp_spp_init(ESP_SPP_MODE_CB)) != ESP_OK) {
    ESP_LOGE(ps5_TAG, "%s spp init failed: %s\n", __func__, esp_err_to_name(ret));
    return;
  }
}

/********************************************************************************/
/*                      L O C A L    F U N C T I O N S                          */
/********************************************************************************/

/*******************************************************************************
**
** Function         sppCallback
**
** Description      Callback for SPP events, only used for the init event to
**                  configure the SPP server
**
** Returns          void
**
*******************************************************************************/
static void sppCallback(esp_spp_cb_event_t event, esp_spp_cb_param_t* param) {
  if (event == ESP_SPP_INIT_EVT) {
    ESP_LOGI(ps5_TAG, "ESP_SPP_INIT_EVT");

#if ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 0, 0)
        esp_bt_gap_set_scan_mode(ESP_BT_CONNECTABLE, ESP_BT_NON_DISCOVERABLE);
#else
        esp_bt_gap_set_scan_mode(ESP_BT_SCAN_MODE_CONNECTABLE);
#endif
  }
}

================
File: ps5-esp32-main\src\osi\allocator.h
================
/******************************************************************************
 *
 *  Copyright (C) 2014 Google, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at:
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 ******************************************************************************/

#ifndef _ALLOCATOR_H_
#define _ALLOCATOR_H_

#include <stddef.h>
#include <stdlib.h>
#include "esp_heap_caps.h"

char *osi_strdup(const char *str);

void *osi_malloc_func(size_t size);
void *osi_calloc_func(size_t size);
void osi_free_func(void *ptr);

#if HEAP_MEMORY_DEBUG

void osi_mem_dbg_init(void);
void osi_mem_dbg_record(void *p, int size, const char *func, int line);
void osi_mem_dbg_clean(void *p, const char *func, int line);
void osi_mem_dbg_show(void);
uint32_t osi_mem_dbg_get_max_size(void);
uint32_t osi_mem_dbg_get_current_size(void);
void osi_men_dbg_set_section_start(uint8_t index);
void osi_men_dbg_set_section_end(uint8_t index);
uint32_t osi_mem_dbg_get_max_size_section(uint8_t index);

#if HEAP_ALLOCATION_FROM_SPIRAM_FIRST
#define osi_malloc(size)                                \
({                                                      \
    void *p;                                            \
    p = heap_caps_malloc_prefer(size, 2,                \
        MALLOC_CAP_DEFAULT|MALLOC_CAP_SPIRAM,           \
        MALLOC_CAP_DEFAULT|MALLOC_CAP_INTERNAL);        \
    osi_mem_dbg_record(p, size, __func__, __LINE__);    \
    (void *)p;                                          \
})

#define osi_calloc(size)                                \
({                                                      \
    void *p;                                            \
    p = heap_caps_calloc_prefer(1, size, 2,             \
        MALLOC_CAP_DEFAULT|MALLOC_CAP_SPIRAM,           \
        MALLOC_CAP_DEFAULT|MALLOC_CAP_INTERNAL);        \
    osi_mem_dbg_record(p, size, __func__, __LINE__);    \
    (void *)p;                                          \
})

#else

#define osi_malloc(size)                                \
({                                                      \
    void *p;                                            \
    p = malloc((size));                                 \
    osi_mem_dbg_record(p, size, __func__, __LINE__);    \
    (void *)p;                                          \
})

#define osi_calloc(size)                                \
({                                                      \
    void *p;                                            \
    p = calloc(1, (size));                              \
    osi_mem_dbg_record(p, size, __func__, __LINE__);    \
    (void *)p;                                          \
})

#endif /* #if HEAP_ALLOCATION_FROM_SPIRAM_FIRST */


#if 0
#define osi_malloc(size)                                \
do {                                                    \
    void *p;                                            \
                                                        \
#if HEAP_ALLOCATION_FROM_SPIRAM_FIRST              \
    p = heap_caps_malloc_prefer(size, 2, MALLOC_CAP_DEFAULT|MALLOC_CAP_SPIRAM, MALLOC_CAP_DEFAULT|MALLOC_CAP_INTERNAL); \
#else                                                   \
    p = malloc((size));                                 \
#endif /* #if HEAP_ALLOCATION_FROM_SPIRAM_FIRST */ \
    osi_mem_dbg_record(p, size, __func__, __LINE__);    \
    (void *)p;                                          \
}while(0)

#define osi_calloc(size)                                \
do {                                                    \
    void *p;                                            \
                                                        \
#if HEAP_ALLOCATION_FROM_SPIRAM_FIRST              \
        p = heap_caps_calloc_prefer(1, size, 2,         \
            MALLOC_CAP_DEFAULT|MALLOC_CAP_SPIRAM,       \
            MALLOC_CAP_DEFAULT|MALLOC_CAP_INTERNAL);    \
#else                                                   \
    p = calloc(1, (size));                              \
#endif /* #if HEAP_ALLOCATION_FROM_SPIRAM_FIRST */ \
    osi_mem_dbg_record(p, size, __func__, __LINE__);    \
    (void *)p;                                          \
} while(0)
#endif

#define osi_free(ptr)                                   \
do {                                                    \
    void *tmp_point = (void *)(ptr);                    \
    osi_mem_dbg_clean(tmp_point, __func__, __LINE__);   \
    free(tmp_point);                                    \
} while (0)

#else

#if HEAP_ALLOCATION_FROM_SPIRAM_FIRST
#define osi_malloc(size)                  heap_caps_malloc_prefer(size, 2, MALLOC_CAP_DEFAULT|MALLOC_CAP_SPIRAM, MALLOC_CAP_DEFAULT|MALLOC_CAP_INTERNAL)
#define osi_calloc(size)                  heap_caps_calloc_prefer(1, size, 2, MALLOC_CAP_DEFAULT|MALLOC_CAP_SPIRAM, MALLOC_CAP_DEFAULT|MALLOC_CAP_INTERNAL)
#else
#define osi_malloc(size)                  malloc((size))
#define osi_calloc(size)                  calloc(1, (size))
#endif /* #if HEAP_ALLOCATION_FROM_SPIRAM_FIRST */
#define osi_free(p)                       free((p))

#endif /* HEAP_MEMORY_DEBUG */

#define FREE_AND_RESET(a)   \
do {                        \
    if (a) {                \
        osi_free(a);        \
        a = NULL;           \
    }                       \
}while (0)


#endif /* _ALLOCATOR_H_ */

================
File: ps5-esp32-main\src\stack\btm_api.h
================
/******************************************************************************
 *
 *  Copyright (C) 1999-2012 Broadcom Corporation
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at:
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 ******************************************************************************/

/******************************************************************************
 *
 *  This file contains the Bluetooth Manager (BTM) API function external
 *  definitions.
 *
 ******************************************************************************/
#ifndef BTM_API_H
#define BTM_API_H


#include "stack/bt_types.h"

/* Security service definitions (BTM_SetSecurityLevel)
** Used for Authorization APIs
*/

/* Update these as services are added */
#define BTM_SEC_SERVICE_FIRST_EMPTY     51

#define BT_DEFAULT_BUFFER_SIZE (4096 + 16)

#ifndef BTM_SEC_MAX_SERVICES
#define BTM_SEC_MAX_SERVICES            65
#endif


/*******************************************************************************
**
** Function         BTM_SetSecurityLevel
**
** Description      Register service security level with Security Manager.  Each
**                  service must register its requirements regardless of the
**                  security level that is used.  This API is called once for originators
**                  nad again for acceptors of connections.
**
** Returns          TRUE if registered OK, else FALSE
**
*******************************************************************************/
//extern
bool BTM_SetSecurityLevel (bool is_originator, const char *p_name,
                              uint8_t service_id, uint16_t sec_level,
                              uint16_t psm, uint32_t mx_proto_id,
                              uint32_t mx_chan_id);

#endif /* BTM_API_H */

================
File: ps5-esp32-main\src\stack\bt_types.h
================
/******************************************************************************
 *
 *  Copyright (C) 1999-2012 Broadcom Corporation
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at:
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 ******************************************************************************/

#ifndef BT_TYPES_H
#define BT_TYPES_H

#include <stdbool.h>
#include <stdint.h>

// typedef uint8_t UINT8;
// typedef uint16_t UINT16;
// typedef uint32_t UINT32;
// typedef uint64_t UINT64;

// typedef int8_t INT8;
// typedef int16_t INT16;
// typedef int32_t INT32;
// typedef bool BOOLEAN;

/* Define the header of each buffer used in the Bluetooth stack.
 */
typedef struct {
  uint16_t event;
  uint16_t length;
  uint16_t offset;
  uint16_t layer_specific;
  uint8_t data[];
} BT_HDR;

#define BT_PSM_HID_CONTROL 0x0011
#define BT_PSM_HID_INTERRUPT 0x0013

typedef struct {
  uint8_t qos_flags;          /* TBD */
  uint8_t service_type;       /* see below */
  uint32_t token_rate;        /* bytes/second */
  uint32_t token_bucket_size; /* bytes */
  uint32_t peak_bandwidth;    /* bytes/second */
  uint32_t latency;           /* microseconds */
  uint32_t delay_variation;   /* microseconds */
} FLOW_SPEC;

/* bd addr length and type */
#ifndef BD_ADDR_LEN
#define BD_ADDR_LEN 6
typedef uint8_t BD_ADDR[BD_ADDR_LEN];
#endif

#endif

================
File: ps5-esp32-main\src\stack\gap_api.h
================
#ifndef GAP_API_H
#define GAP_API_H

#include "stack/l2c_api.h"

/*****************************************************************************
**  Constants
*****************************************************************************/
/*** GAP Error and Status Codes ***/
#define GAP_EVT_CONN_OPENED 0x0100
#define GAP_EVT_CONN_CLOSED 0x0101
#define GAP_EVT_CONN_DATA_AVAIL 0x0102
#define GAP_EVT_CONN_CONGESTED 0x0103
#define GAP_EVT_CONN_UNCONGESTED 0x01043

/*** used in connection variables and functions ***/
#define GAP_INVALID_HANDLE 0xFFFF

/*** Used for general successful function returns ***/
#define BT_PASS 0

/*****************************************************************************
**  Type Definitions
*****************************************************************************/
/*
** Callback function for connection services
*/
typedef void(tGAP_CONN_CALLBACK)(uint16_t gap_handle, uint16_t event);

/*****************************************************************************
**  External Function Declarations
*****************************************************************************/

/*** Functions for L2CAP connection interface ***/

/*******************************************************************************
**
** Function         GAP_ConnOpen
**
** Description      This function is called to open a generic L2CAP connection.
**
** Returns          handle of the connection if successful, else GAP_INVALID_HANDLE
**
*******************************************************************************/
extern uint16_t GAP_ConnOpen(const char* p_serv_name, uint8_t service_id, bool is_server, BD_ADDR p_rem_bda,
  uint16_t psm, tL2CAP_CFG_INFO* p_cfg, tL2CAP_ERTM_INFO* ertm_info, uint16_t security, uint8_t chan_mode_mask,
  tGAP_CONN_CALLBACK* p_cb);

/*******************************************************************************
**
** Function         GAP_ConnClose
**
** Description      This function is called to close a connection.
**
** Returns          BT_PASS             - closed OK
**                  GAP_ERR_BAD_HANDLE  - invalid handle
**
*******************************************************************************/
extern uint16_t GAP_ConnClose(uint16_t gap_handle);

/*******************************************************************************
**
** Function         GAP_ConnBTRead
**
** Description      GKI buffer aware applications will call this function after
**                  receiving an GAP_EVT_RXDATA event to process the incoming
**                  data buffer.
**
** Returns          BT_PASS             - data read
**                  GAP_ERR_BAD_HANDLE  - invalid handle
**                  GAP_NO_DATA_AVAIL   - no data available
**
*******************************************************************************/
extern uint16_t GAP_ConnBTRead(uint16_t gap_handle, BT_HDR** pp_buf);

/*******************************************************************************
**
** Function         GAP_ConnBTWrite
**
** Description      GKI buffer aware applications can call this function to write data
**                  by passing a pointer to the GKI buffer of data.
**
** Returns          BT_PASS                 - data read
**                  GAP_ERR_BAD_HANDLE      - invalid handle
**                  GAP_ERR_BAD_STATE       - connection not established
**                  GAP_INVALID_BUF_OFFSET  - buffer offset is invalid
*******************************************************************************/
extern uint16_t GAP_ConnBTWrite(uint16_t gap_handle, BT_HDR* p_buf);

/*******************************************************************************
**
** Function         GAP_ConnGetL2CAPCid
**
** Description      Returns the L2CAP channel id
**
** Parameters:      handle      - Handle of the connection
**
** Returns          uint16_t      - The L2CAP channel id
**                  0, if error
**
*******************************************************************************/
extern uint16_t GAP_ConnGetL2CAPCid(uint16_t gap_handle);

#endif /* GAP_API_H */

================
File: ps5-esp32-main\src\stack\hcidefs.h
================
#ifndef HCIDEFS_H
#define HCIDEFS_H

#include "stack/bt_types.h"

/* Define the extended flow specification fields used by AMP */
typedef struct {
  uint8_t id;
  uint8_t stype;
  uint16_t max_sdu_size;
  uint32_t sdu_inter_time;
  uint32_t access_latency;
  uint32_t flush_timeout;
} tHCI_EXT_FLOW_SPEC;

#endif

================
File: ps5-esp32-main\src\stack\l2cdefs.h
================
/******************************************************************************
 *
 *  Copyright (C) 1999-2012 Broadcom Corporation
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at:
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 ******************************************************************************/

#ifndef L2CDEFS_H
#define L2CDEFS_H

/* Define the L2CAP connection result codes
*/
#define L2CAP_CONN_OK                0
#define L2CAP_CONN_PENDING           1
#define L2CAP_CONN_NO_PSM            2
#define L2CAP_CONN_SECURITY_BLOCK    3
#define L2CAP_CONN_NO_RESOURCES      4
#define L2CAP_CONN_BAD_CTLR_ID       5              /* AMP related */
#define L2CAP_CONN_TIMEOUT           0xEEEE
#define L2CAP_CONN_AMP_FAILED        254
#define L2CAP_CONN_NO_LINK           255        /* Add a couple of our own for internal use */
#define L2CAP_CONN_CANCEL            256        /* L2CAP connection cancelled */


/* Define the L2CAP configuration result codes
*/
#define L2CAP_CFG_OK                    0
#define L2CAP_CFG_UNACCEPTABLE_PARAMS   1
#define L2CAP_CFG_FAILED_NO_REASON      2
#define L2CAP_CFG_UNKNOWN_OPTIONS       3
#define L2CAP_CFG_PENDING               4
#define L2CAP_CFG_FLOW_SPEC_REJECTED    5

#endif

================
File: ps5-esp32-main\src\stack\l2c_api.h
================
/******************************************************************************
 *
 *  Copyright (C) 1999-2012 Broadcom Corporation
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at:
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 ******************************************************************************/

/******************************************************************************
 *
 *  this file contains the L2CAP API definitions
 *
 ******************************************************************************/
#ifndef L2C_API_H
#define L2C_API_H

#include <stdbool.h>

#include "stack/l2cdefs.h"
#include "stack/hcidefs.h"
#include "stack/btm_api.h"

/*****************************************************************************
**  Constants
*****************************************************************************/

/* Define the minimum offset that L2CAP needs in a buffer. This is made up of
** HCI type(1), len(2), handle(2), L2CAP len(2) and CID(2) => 9
*/
#define L2CAP_MIN_OFFSET 13 /* plus control(2), SDU length(2) */

/* result code for L2CA_DataWrite() */
#define L2CAP_DW_FAILED        false
#define L2CAP_DW_SUCCESS       true
#define L2CAP_DW_CONGESTED     2


/*****************************************************************************
**  Type Definitions
*****************************************************************************/

typedef struct {
#define L2CAP_FCR_BASIC_MODE    0x00
#define L2CAP_FCR_ERTM_MODE     0x03
#define L2CAP_FCR_STREAM_MODE   0x04

  uint8_t mode;

  uint8_t tx_win_sz;
  uint8_t max_transmit;
  uint16_t rtrans_tout;
  uint16_t mon_tout;
  uint16_t mps;
} tL2CAP_FCR_OPTS;

/* Define a structure to hold the configuration parameters. Since the
** parameters are optional, for each parameter there is a boolean to
** use to signify its presence or absence.
*/
typedef struct {
  uint16_t result; /* Only used in confirm messages */
  bool mtu_present;
  uint16_t mtu;
  bool qos_present;
  FLOW_SPEC qos;
  bool flush_to_present;
  uint16_t flush_to;
  bool fcr_present;
  tL2CAP_FCR_OPTS fcr;
  bool fcs_present; /* Optionally bypasses FCS checks */
  uint8_t fcs;      /* '0' if desire is to bypass FCS, otherwise '1' */
  bool ext_flow_spec_present;
  tHCI_EXT_FLOW_SPEC ext_flow_spec;
  uint16_t flags; /* bit 0: 0-no continuation, 1-continuation */
} tL2CAP_CFG_INFO;


/*********************************
**  Callback Functions Prototypes
**********************************/

/* Connection indication callback prototype. Parameters are
**              BD Address of remote
**              Local CID assigned to the connection
**              PSM that the remote wants to connect to
**              Identifier that the remote sent
*/
typedef void (tL2CA_CONNECT_IND_CB) (BD_ADDR, uint16_t, uint16_t, uint8_t);


/* Connection confirmation callback prototype. Parameters are
**              Local CID
**              Result - 0 = connected, non-zero means failure reason
*/
typedef void (tL2CA_CONNECT_CFM_CB) (uint16_t, uint16_t);


/* Connection pending callback prototype. Parameters are
**              Local CID
*/
typedef void (tL2CA_CONNECT_PND_CB) (uint16_t);


/* Configuration indication callback prototype. Parameters are
**              Local CID assigned to the connection
**              Pointer to configuration info
*/
typedef void (tL2CA_CONFIG_IND_CB) (uint16_t, tL2CAP_CFG_INFO *);


/* Configuration confirm callback prototype. Parameters are
**              Local CID assigned to the connection
**              Pointer to configuration info
*/
typedef void (tL2CA_CONFIG_CFM_CB) (uint16_t, tL2CAP_CFG_INFO *);


/* Disconnect indication callback prototype. Parameters are
**              Local CID
**              bool whether upper layer should ack this
*/
typedef void (tL2CA_DISCONNECT_IND_CB) (uint16_t, bool);


/* Disconnect confirm callback prototype. Parameters are
**              Local CID
**              Result
*/
typedef void (tL2CA_DISCONNECT_CFM_CB) (uint16_t, uint16_t);


/* QOS Violation indication callback prototype. Parameters are
**              BD Address of violating device
*/
typedef void (tL2CA_QOS_VIOLATION_IND_CB) (BD_ADDR);


/* Data received indication callback prototype. Parameters are
**              Local CID
**              Address of buffer
*/
typedef void (tL2CA_DATA_IND_CB) (uint16_t, BT_HDR *);


/* Congestion status callback protype. This callback is optional. If
** an application tries to send data when the transmit queue is full,
** the data will anyways be dropped. The parameter is:
**              Local CID
**              TRUE if congested, FALSE if uncongested
*/
typedef void (tL2CA_CONGESTION_STATUS_CB) (uint16_t, bool);


/* Transmit complete callback protype. This callback is optional. If
** set, L2CAP will call it when packets are sent or flushed. If the
** count is 0xFFFF, it means all packets are sent for that CID (eRTM
** mode only). The parameters are:
**              Local CID
**              Number of SDUs sent or dropped
*/
typedef void (tL2CA_TX_COMPLETE_CB) (uint16_t, uint16_t);


/* Define the structure that applications use to register with
** L2CAP. This structure includes callback functions. All functions
** MUST be provided, with the exception of the "connect pending"
** callback and "congestion status" callback.
*/
typedef struct {
    tL2CA_CONNECT_IND_CB        *pL2CA_ConnectInd_Cb;
    tL2CA_CONNECT_CFM_CB        *pL2CA_ConnectCfm_Cb;
    tL2CA_CONNECT_PND_CB        *pL2CA_ConnectPnd_Cb;
    tL2CA_CONFIG_IND_CB         *pL2CA_ConfigInd_Cb;
    tL2CA_CONFIG_CFM_CB         *pL2CA_ConfigCfm_Cb;
    tL2CA_DISCONNECT_IND_CB     *pL2CA_DisconnectInd_Cb;
    tL2CA_DISCONNECT_CFM_CB     *pL2CA_DisconnectCfm_Cb;
    tL2CA_QOS_VIOLATION_IND_CB  *pL2CA_QoSViolationInd_Cb;
    tL2CA_DATA_IND_CB           *pL2CA_DataInd_Cb;
    tL2CA_CONGESTION_STATUS_CB  *pL2CA_CongestionStatus_Cb;
    tL2CA_TX_COMPLETE_CB        *pL2CA_TxComplete_Cb;

} tL2CAP_APPL_INFO;

/* Define the structure that applications use to create or accept
** connections with enhanced retransmission mode.
*/
typedef struct {
    uint8_t       preferred_mode;
    uint8_t       allowed_modes;
    uint16_t      user_rx_buf_size;
    uint16_t      user_tx_buf_size;
    uint16_t      fcr_rx_buf_size;
    uint16_t      fcr_tx_buf_size;

} tL2CAP_ERTM_INFO;

#define L2CA_REGISTER(a,b,c)        L2CA_Register(a,(tL2CAP_APPL_INFO *)b)
#define L2CA_DEREGISTER(a)          L2CA_Deregister(a)
#define L2CA_CONNECT_REQ(a,b,c,d)   L2CA_ErtmConnectReq(a,b,c)
#define L2CA_CONNECT_RSP(a,b,c,d,e,f,g) L2CA_ErtmConnectRsp(a,b,c,d,e,f)
#define L2CA_CONFIG_REQ(a,b)        L2CA_ConfigReq(a,b)
#define L2CA_CONFIG_RSP(a,b)        L2CA_ConfigRsp(a,b)
#define L2CA_DISCONNECT_REQ(a)      L2CA_DisconnectReq(a)
#define L2CA_DISCONNECT_RSP(a)      L2CA_DisconnectRsp(a)
#define L2CA_DATA_WRITE(a, b)       L2CA_DataWrite(a, b)

/*****************************************************************************
**  External Function Declarations
*****************************************************************************/
#ifdef __cplusplus
extern "C"
{
#endif

/*******************************************************************************
**
** Function         L2CA_Register
**
** Description      Other layers call this function to register for L2CAP
**                  services.
**
** Returns          PSM to use or zero if error. Typically, the PSM returned
**                  is the same as was passed in, but for an outgoing-only
**                  connection to a dynamic PSM, a "virtual" PSM is returned
**                  and should be used in the calls to L2CA_ConnectReq() and
**                  BTM_SetSecurityLevel().
**
*******************************************************************************/
extern uint16_t L2CA_Register (uint16_t psm, tL2CAP_APPL_INFO *p_cb_info);

/*******************************************************************************
**
** Function         L2CA_Deregister
**
** Description      Other layers call this function to deregister for L2CAP
**                  services.
**
** Returns          void
**
*******************************************************************************/
extern void L2CA_Deregister (uint16_t psm);

/*******************************************************************************
**
** Function         L2CA_ErtmConnectReq
**
** Description      Higher layers call this function to create an L2CAP connection
**                  that needs to use Enhanced Retransmission Mode.
**                  Note that the connection is not established at this time, but
**                  connection establishment gets started. The callback function
**                  will be invoked when connection establishes or fails.
**
** Returns          the CID of the connection, or 0 if it failed to start
**
*******************************************************************************/
extern uint16_t L2CA_ErtmConnectReq (uint16_t psm, BD_ADDR p_bd_addr,
                                   tL2CAP_ERTM_INFO *p_ertm_info);

/*******************************************************************************
**
** Function         L2CA_ErtmConnectRsp
**
** Description      Higher layers call this function to accept an incoming
**                  L2CAP connection, for which they had gotten an connect
**                  indication callback, and for which the higher layer wants
**                  to use Enhanced Retransmission Mode.
**
** Returns          TRUE for success, FALSE for failure
**
*******************************************************************************/
extern bool  L2CA_ErtmConnectRsp (BD_ADDR p_bd_addr, uint8_t id, uint16_t lcid,
                                     uint16_t result, uint16_t status,
                                     tL2CAP_ERTM_INFO *p_ertm_info);

/*******************************************************************************
**
** Function         L2CA_ConfigReq
**
** Description      Higher layers call this function to send configuration.
**
** Returns          TRUE if configuration sent, else FALSE
**
*******************************************************************************/
extern bool L2CA_ConfigReq (uint16_t cid, tL2CAP_CFG_INFO *p_cfg);

/*******************************************************************************
**
** Function         L2CA_ConfigRsp
**
** Description      Higher layers call this function to send a configuration
**                  response.
**
** Returns          TRUE if configuration response sent, else FALSE
**
*******************************************************************************/
extern bool L2CA_ConfigRsp (uint16_t cid, tL2CAP_CFG_INFO *p_cfg);

/*******************************************************************************
**
** Function         L2CA_DisconnectReq
**
** Description      Higher layers call this function to disconnect a channel.
**
** Returns          TRUE if disconnect sent, else FALSE
**
*******************************************************************************/
extern bool L2CA_DisconnectReq (uint16_t cid);

/*******************************************************************************
**
** Function         L2CA_DisconnectRsp
**
** Description      Higher layers call this function to acknowledge the
**                  disconnection of a channel.
**
** Returns          void
**
*******************************************************************************/
extern bool L2CA_DisconnectRsp (uint16_t cid);

/*******************************************************************************
**
** Function         L2CA_DataWrite
**
** Description      Higher layers call this function to write data.
**
** Returns          L2CAP_DW_SUCCESS, if data accepted, else FALSE
**                  L2CAP_DW_CONGESTED, if data accepted and the channel is congested
**                  L2CAP_DW_FAILED, if error
**
*******************************************************************************/
extern uint8_t L2CA_DataWrite (uint16_t cid, BT_HDR *p_data);


#ifdef __cplusplus
}
#endif

#endif  /* L2C_API_H */
